SETG modaptoProperties:(map())
CF_LOAD_CONFIG_FROM_FILE configFile:("db:\\modapto.properties") configMap:modaptoProperties
SETG mscBaseEndpoint:(cond(type(modaptoProperties["servicesBaseUrl"]) != "undefined" AND modaptoProperties["servicesBaseUrl"] != "", modaptoProperties["servicesBaseUrl"], "http://127.0.0.1:8080"))
#SETG mscBaseEndpoint:("http://127.0.0.1:8080")

SETG keycloak_username:("")
SETG keycloak_password:("")
PROCEDURE global KEYCLOAK_LOGIN {
  SETG keycloak_username:("")
  SETG keycloak_password:("")
  ASK_KEYCLOAK_CREDENTIALS username:username password:password
  IF (username = "" AND password = "") {
    EXIT
  }
  KEYCLOAK_GET_ACCESS_TOKEN token_url:(modaptoProperties["keycloakBaseUrl"]+"/realms/"+modaptoProperties["keycloakRealm"]+"/protocol/openid-connect/token") client_id:(modaptoProperties["keycloakClientId"]) client_secret:(modaptoProperties["keycloakClientSecret"]) username:(username) password:(password) access_token:access_token email:email
  IF (email = "") {
    EXIT
  }
  SETG keycloak_username:(username)
  SETG keycloak_password:(password)
  CC "AdoScript" INFOBOX ("Login Successful " + email)
}

PROCEDURE global KEYCLOAK_LOGOUT {
  SETG keycloak_username:("")
  SETG keycloak_password:("")
  CC "AdoScript" INFOBOX "Logout Successful"
}

PROCEDURE global ASK_KEYCLOAK_CREDENTIALS username:reference password:reference {
  SETL username:("")
  SETL password:("")
  CC "AdoScript" GET_TEMP_FILENAME
  #NOTE: https://stackoverflow.com/questions/5596982/using-powershell-to-write-a-file-in-utf-8-without-the-bom
  SYSTEM ("powershell -Command \"$credentials = $host.ui.promptForCredential('MODAPTO Login', 'Login with your MODAPTO credentials', '', 'MODAPTO_ADOXX_CLIENT_TARGET', 1, 0) ; $null = New-Item -Force "+filename+" -Value ($credentials.GetNetworkCredential().Username + '\n' + $credentials.GetNetworkCredential().Password)\"") with-console-window hide result:res
  IF (res = 0) {
    CC "AdoScript" FREAD file:(filename)
    SETL username:(token(text, 0, "\n"))
    SETL password:(token(text, 1, "\n"))
  }
  CC "AdoScript" FILE_DELETE file:(filename)
  #CC "AdoScript" VIEWBOX text:("username: " + username + "\npassword: " + password)
}
#ASK_KEYCLOAK_CREDENTIALS username:keycloak_username password:keycloak_password

PROCEDURE global KEYCLOAK_GET_ACCESS_TOKEN token_url:string client_id:string client_secret:string username:string password:string access_token:reference email:reference {
  SETL access_token:("")
  SETL email:("")
  CC "AdoScript" HTTP_REQUEST (token_url) method:("POST") reqheader:({"Content-Type":"application/x-www-form-urlencoded"}) reqbody:("password=" + encodeuri(password) + "&username=" + encodeuri(username) + "&client_id=" + encodeuri(client_id) + "&client_secret=" + encodeuri(client_secret) + "&grant_type=password")
  IF (ecode <> 0) {
    CC "AdoScript" ERRORBOX (errmsg)
  } ELSE {
    IF (statuscode < 200 OR statuscode >= 300) {
      CC "AdoScript" ERRORBOX ("HTTP Status Code: " + STR(statuscode) + "\n" + response)
    } ELSE {
      #CC "AdoScript" VIEWBOX text:(response)
      SETL auth_json:(fromJson(response))
      IF (type(auth_json["error"]) != "undefined") {
        CC "AdoScript" ERRORBOX (auth_json["error_description"])
      } ELSE {
        SETL access_token:(auth_json["access_token"])
        SETL payloadB64:(token(access_token, 1, "."))
        WHILE (LEN payloadB64 MOD 4 != 0) {
          SETL payloadB64:(payloadB64 + "=")
        }
        SETL payload:(base64decode(payloadB64))
        SETL payload_json:(fromJson(payload))
        SETL email:(payload_json["email"])
        #CC "AdoScript" VIEWBOX text:("access_token:"+access_token+"\nemail:"+email)
      }
    }
  }
}
#KEYCLOAK_GET_ACCESS_TOKEN token_url:("https://keycloak.modapto.atc.gr/realms/modapto-system/protocol/openid-connect/token") client_id:("modapto") client_secret:("y1veMO61XI8tlbFKM24emcyY1Q29UKJq") username:("damiano.falcioni@boc-group.com") password:("@Damiano123@") access_token:access_token email:email

PROCEDURE global GENERATE_AUTHORIZATION_HEADER headersMap:reference {
  SETL headersMap:(map())
  IF (keycloak_username != "" AND keycloak_password != "") {
    KEYCLOAK_GET_ACCESS_TOKEN token_url:(modaptoProperties["keycloakBaseUrl"]+"/realms/"+modaptoProperties["keycloakRealm"]+"/protocol/openid-connect/token") client_id:(modaptoProperties["keycloakClientId"]) client_secret:(modaptoProperties["keycloakClientSecret"]) username:(keycloak_username) password:(keycloak_password) access_token:access_token email:email
    IF (access_token != "") {
      SETL headersMap:({"Authorization":"Bearer " + access_token})
    }
  }
}

PROCEDURE global DATA_BINDING_IMPORT_FROM_CATALOG {
  CC "AdoScript" EDITFIELD title:"Enter the MODAPTO Orchestrator Base URL" caption:"MODAPTO Orchestrator Base URL:" text:(mscBaseEndpoint)
  IF (ecode != 0) {
      EXIT
  }
  SETG mscBaseEndpoint:(text)

  GENERATE_AUTHORIZATION_HEADER headersMap:headersMap
  CC "AdoScript" HTTP_REQUEST (mscBaseEndpoint + "/micro-service-controller-rest/rest/msc/callMicroserviceForced?microserviceId=2daf6c38-4579-4929-8d72-4d869c9bcc4e&operationId=getServicesList") reqheader:(headersMap)
  SETL servicesList:(fromJson(response)["data", "list"])
  SETL servicesListEntries:("")
  FOR i from:(0) to:(LEN servicesList - 1) {
    SETL servicesListEntries:(servicesListEntries + ";" + servicesList[i, "name"])
  }
  IF (servicesListEntries != "") {
    SETL servicesListEntries: (copy(servicesListEntries, 1, LEN(servicesListEntries) - 1))
  }
  CC "AdoScript" LISTBOX entries:(servicesListEntries) toksep:";" title:"Services" oktext:"Select" boxtext:"Choose the service to import" 
  IF (endbutton != "ok") {
   EXIT
  }
  SETL selectionID:("")
  FOR i from:(0) to:(LEN servicesList - 1) {
    IF (selection = servicesList[i, "name"]) {
      SETL selectionID:(servicesList[i, "id"])
      BREAK
    }
  }
  CC "AdoScript" HTTP_REQUEST (mscBaseEndpoint + "/micro-service-controller-rest/rest/msc/callMicroserviceCustomIO/2daf6c38-4579-4929-8d72-4d869c9bcc4e/getService?id=" + encodeuri(selectionID)) reqheader:(headersMap)
  SETL service:(fromJson(response))
  SETL service["id"]:(selectionID)
  
  SETL classname:("")
  IF (service["type"]="internal") {
    SETL classname:("Internal Service")
  } ELSIF (service["type"]="external") {
    SETL classname:("External Service")
  } ELSE {
    SETL classname:("FMU")
  }
  CC "Modeling" GET_ACT_MODEL
  IF (modelid = -1) {
    CC "AdoScript" ERRORBOX ("No active model")
    EXIT
  }
  CC "Core" GET_MODEL_INFO modelid:(modelid)
  IF (modeltype != "Data Binding Model") {
    CC "AdoScript" ERRORBOX ("The active Model is not Data Binding Model")
    EXIT
  }
  SETL nModelId:(modelid)
  CC "Core" GET_CLASS_ID classname:(classname)
  CC "Core" CREATE_OBJ modelid:(nModelId) classid:(classid) objname:(service["name"])
  IF (ecode != 0) {
    CC "AdoScript" ERRORBOX (errtext)
    EXIT
  }
  SETL nObjId:(objid)
  CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("catalogueId") val:(service["id"]) as-string
  CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("Description") val:(service["description_short"]) as-string
  CC "Modeling" SAVE modelid:(nModelId)
  CC "AdoScript" VIEWBOX text:(service)
}

PROCEDURE global AAS_IMPORT_JSON {
  CC "AdoScript" FILE_DIALOG open filter1:"JSON" type1:"*.json"
  IF (endbutton = "ok") {
    CC "AdoScript" FREAD file:(path)
    CC "Application" GET_DATE_TIME date-format:"YYYY.MM.DD" time-format:"HH:MM:SS"
    AAS_LOAD_JSON json:(fromJson(text)) modelname:("AAS-" + date + "_" + time) modelgroup: ("Exercises")
    CC "AdoScript" INFOBOX "Import Completed"
  }
}

PROCEDURE global AAS_EXPORT_JSON {
  CC "ImportExport" SHOW_EXPORT_DLG multi-select:0 mode: "json" title: "Select the Models to export" filedescription: "json format" fileextension: "*.json"
  IF (endbutton != "ok") {
    EXIT
  }
  SETL sExportPath:(filename)
  AAS_GENERATE_JSON nModelId:(VAL modelids) json:json_map
  SETL sJSON:(mapToJson(json_map))
  SETL sJSON:(replall(sJSON, "\"__True\"", "true"))
  SETL sJSON:(replall(sJSON, "\"__False\"", "false"))
  #CC "AdoScript" VIEWBOX text:(sJSON)
  VALIDATE_AAS aas:(sJSON) result:validationResult
  IF (validationResult = "ok") {
    CC "AdoScript" FWRITE file:(sExportPath) text:(sJSON) append:0 binary:0 base64:0
    CC "AdoScript" INFOBOX "Export Completed"
  } ELSE {
    CC "AdoScript" ERRORBOX ("AAS Validation Error:\n" + validationResult)
  }
}

PROCEDURE global AAS_LOAD_JSON json:map modelname:string modelgroup:string {

}


PROCEDURE global AAS_GENERATE_JSON nModelId:integer json:reference {
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  CC "Modeling" OPEN modelids:(nModelId)

  SETL assetAdministrationShells:(array(0))
  CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(nModelId) classname:"AssetAdministrationShell"
  FOR sAssetAdministrationShellId in:(objids) {
    PROCESS_ASSETADMINISTRATIONSHELL_JSON objid:(VAL sAssetAdministrationShellId) json:val
    IF (LEN val > 0) {
      SETL dummy:(aappend(assetAdministrationShells, val))
    }
  }
  IF (LEN assetAdministrationShells > 0) {
    SETL json["assetAdministrationShells"]:(assetAdministrationShells)
  }

  SETL submodels:(array(0))
  CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(nModelId) classname:"Submodel"
  FOR sSubmodelId in:(objids) {
    PROCESS_SUBMODEL_JSON objid:(VAL sSubmodelId) json:val
    IF (LEN val > 0) {
      SETL dummy:(aappend(submodels, val))
    }
  }
  IF (LEN submodels > 0) {
    SETL json["submodels"]:(submodels)
  }

  SETL conceptDescriptions:(array(0))
  CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(nModelId) classname:"ConceptDescription"
  FOR sConceptDescriptionId in:(objids) {
    PROCESS_CONCEPTDESCRIPTION_JSON objid:(VAL sConceptDescriptionId) json:val
    IF (LEN val > 0) {
      SETL dummy:(aappend(conceptDescriptions, val))
    }
  }
  IF (LEN conceptDescriptions > 0) {
    SETL json["conceptDescriptions"]:(conceptDescriptions)
  }
}



PROCEDURE global PROCESS_ASSETADMINISTRATIONSHELL_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("AssetAdministrationShell") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #Identifiable
  #Referable
  #HasExtensions
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("extension") records:({"extension": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["extensions"]:(val)
  }
  #HasExtensions
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("category") as-string
  IF (LEN val > 0) {
    SETL json["category"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("idShort") as-string
  IF (LEN val > 0) {
    SETL json["idShort"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("displayName") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["displayName"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("description") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["description"]:(val)
  }
  #Referable
  #AdministrativeInformation begin
  SETL administration:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (administration, "dummy"))
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("version") as-string
  IF (LEN val > 0) {
    SETL administration["version"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("revision") as-string
  IF (LEN val > 0) {
    SETL administration["revision"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("templateId") as-string
  IF (LEN val > 0) {
    SETL administration["templateId"]:(val)
  }
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("creator") json:val
  IF (LEN val > 0) {
    SETL administration["creator"]:(val)
  }
  IF (LEN administration > 0) {
    SETL json["administration"]:(administration)
  }
  #AdministrativeInformation end
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("id") as-string
  ERROR_IF_EMPTY val:(val) objid:(objid) desc:("id on AssetAdministrationShell")
  SETL json["id"]:(val)
  #Identifiable
  #HasDataSpecification
  ##missing
  #HasDataSpecification
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("derivedFrom") json:val
  IF (LEN val > 0) {
    SETL json["derivedFrom"]:(val)
  }
  #CC "Core" GET_OBJ_NAME objid:(objid)
  #CC "Core" GET_MODEL_ID objid:(objid)
  #CC "AQL" EVAL_AQL_EXPRESSION expr:("({\""+objname+"\":\"AssetAdministrationShell\"} -> \"derivedFrom\")") modelid: (modelid)
  #IF (tokcnt(objids) > 1) {
  #  CC "AdoScript" ERRORBOX ("Only 1 derivedFrom relation allowed: Object " +  objname)
  #  EXIT
  #}
  #FOR derivedFrom_objid in:(objids) {
  #  
  #}
  #AssetInformation
  SETL assetInformation:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (assetInformation, "dummy"))
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("assetKind") as-string
  ERROR_IF_EMPTY val:(val) objid:(objid) desc:("assetKind on AssetAdministrationShell")
  SETL assetInformation["assetKind"]:(val)
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("globalAssetId") as-string
  IF (LEN val > 0) {
    SETL assetInformation["globalAssetId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("specificAssetId") records:({"specificAssetId": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["specificAssetIds"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("assetType") as-string
  IF (LEN val > 0) {
    SETL assetInformation["assetType"]:(val)
  }
  SETL defaultThumbnail:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (defaultThumbnail, "dummy"))
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("defaultThumbnail_contentType") as-string
  IF (LEN val > 0) {
    SETL defaultThumbnail["contentType"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("defaultThumbnail_path") as-string
  IF (LEN val > 0) {
    SETL defaultThumbnail["path"]:(val)
  }
  IF (type(defaultThumbnail["contentType"]) != "undefined" AND type(defaultThumbnail["defaultThumbnail_path"]) = "undefined") {
    CC "AdoScript" ERRORBOX ("defaultThumbnail_path must be provided when defaultThumbnail_contentType is provided: AssetAdministrationShell Object " +  STR(objid))
    EXIT
  }
  IF (LEN defaultThumbnail > 0) {
    SETL json["defaultThumbnail"]:(defaultThumbnail)
  }
  ERROR_IF_EMPTY_M val:(assetInformation) objid:(objid) desc:("AssetInformation on AssetAdministrationShell")
  SETL json["assetInformation"]:(assetInformation)
  #AssetInformation

  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("submodels") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["submodels"]:(val)
  }
  #CC "AdoScript" VIEWBOX text:(val)
  SETL json["modelType"]:("AssetAdministrationShell")
}

PROCEDURE global PROCESS_SUBMODEL_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("Submodel") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #Identifiable
  #Referable
  #HasExtensions
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("extension") records:({"extension": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["extensions"]:(val)
  }
  #HasExtensions
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("category") as-string
  IF (LEN val > 0) {
    SETL json["category"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("idShort") as-string
  IF (LEN val > 0) {
    SETL json["idShort"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("displayName") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["displayName"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("description") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["description"]:(val)
  }
  #Referable
  #AdministrativeInformation
  SETL administration:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (administration, "dummy"))
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("version") as-string
  IF (LEN val > 0) {
    SETL administration["version"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("revision") as-string
  IF (LEN val > 0) {
    SETL administration["revision"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("templateId") as-string
  IF (LEN val > 0) {
    SETL administration["templateId"]:(val)
  }
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("creator") json:val
  IF (LEN val > 0) {
    SETL administration["creator"]:(val)
  }
  IF (LEN administration > 0) {
    SETL json["administration"]:(administration)
  }
  #AdministrativeInformation
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("id") as-string
  ERROR_IF_EMPTY val:(val) objid:(objid) desc:("id on Submodel")
  SETL json["id"]:(val)
  #Identifiable
  #HasKind
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("kind") as-string
  IF (LEN val > 0) {
    SETL json["kind"]:(val)
  }
  #HasKind
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  #Qualifiable
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("qualifier") records:({"qualifier": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["qualifiers"]:(val)
  }
  #SETL json["modelType"]:("")
  #Qualifiable
  #HasDataSpecification
  ##missing
  #HasDataSpecification
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("submodelElement") records:({"submodelElement": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["submodelElements"]:(val)
  }
  SETL json["modelType"]:("Submodel")
}

PROCEDURE global PROCESS_CONCEPTDESCRIPTION_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("ConceptDescription") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #Identifiable
  #Referable
  #HasExtensions
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("extension") records:({"extension": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["extensions"]:(val)
  }
  #HasExtensions
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("category") as-string
  IF (LEN val > 0) {
    SETL json["category"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("idShort") as-string
  IF (LEN val > 0) {
    SETL json["idShort"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("displayName") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["displayName"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("description") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["description"]:(val)
  }
  #Referable
  #AdministrativeInformation begin
  SETL administration:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (administration, "dummy"))
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("version") as-string
  IF (LEN val > 0) {
    SETL administration["version"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("revision") as-string
  IF (LEN val > 0) {
    SETL administration["revision"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("templateId") as-string
  IF (LEN val > 0) {
    SETL administration["templateId"]:(val)
  }
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("creator") json:val
  IF (LEN val > 0) {
    SETL administration["creator"]:(val)
  }
  IF (LEN administration > 0) {
    SETL json["administration"]:(administration)
  }
  #AdministrativeInformation end
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("id") as-string
  ERROR_IF_EMPTY val:(val) objid:(objid) desc:("id on ConceptDescription")
  SETL json["id"]:(val)
  #Identifiable
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("isCaseOf") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["isCaseOf"]:(val)
  }
  SETL json["modelType"]:("ConceptDescription")
}

PROCEDURE global PROCESS_REFERENCE_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("Reference") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("type") as-string
  ERROR_IF_EMPTY val:(val) objid:(objid) desc:("type on Reference")
  SETL json["type"]:(val)
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("key") records:({"type": { "type": "string", "required": "true" }, "value": { "type": "string", "required": "true" }}) jsonArray:val
  ERROR_IF_EMPTY_A val:(val) objid:(objid) desc:("keys on Reference")
  SETL json["keys"]:(val)
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("referredSemanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["referredSemanticId"]:(val)
  }
}

PROCEDURE global PROCESS_EXTENSION_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("Extension") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("name") as-string
  ERROR_IF_EMPTY val:(val) objid:(objid) desc:("name on Extension")
  SETL json["name"]:(val)
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("valueType") as-string
  IF (LEN val > 0 ) {
    SETL json["valueType"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("value") as-string
  IF (LEN val > 0 ) {
    SETL json["value"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["refersTo"]:(val)
  }
}

PROCEDURE global PROCESS_SPECIFICASSETID_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("SpecificAssetId") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("name") as-string
  ERROR_IF_EMPTY val:(val) objid:(objid) desc:("name on Extension")
  SETL json["name"]:(val)
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("value") as-string
  ERROR_IF_EMPTY val:(val) objid:(objid) desc:("value on Extension")
  SETL json["value"]:(val)
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("externalSubjectId") json:val
  IF (LEN val > 0 ) {
    SETL json["externalSubjectId"]:(val)
  }
}

PROCEDURE global PROCESS_DATASPECIFICATION_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("DataSpecification") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #todo: evaluate how to handle
}
PROCEDURE global PROCESS_QUALIFIER_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("Qualifier") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("kind") as-string
  IF (LEN val > 0) {
    SETL json["kind"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("type") as-string
  ERROR_IF_EMPTY val:(val) objid:(objid) desc:("type on Qualifier")
  SETL json["type"]:(val)
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("valueType") as-string
  ERROR_IF_EMPTY val:(val) objid:(objid) desc:("valueType on Qualifier")
  SETL json["valueType"]:(val)
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("value") as-string
  IF (LEN val > 0) {
    SETL json["value"]:(val)
  }
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("valueId") json:val
  IF (LEN val > 0 ) {
    SETL json["valueId"]:(val)
  }
}
PROCEDURE global PROCESS_RELATIONSHIPELEMENT_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("RelationshipElement") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #RelationshipElement_abstract
  #SubmodelElement
  #Referable
  #HasExtensions
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("extension") records:({"extension": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["extensions"]:(val)
  }
  #HasExtensions
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("category") as-string
  IF (LEN val > 0) {
    SETL json["category"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("idShort") as-string
  IF (LEN val > 0) {
    SETL json["idShort"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("displayName") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["displayName"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("description") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["description"]:(val)
  }
  #Referable
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  #Qualifiable
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("qualifier") records:({"qualifier": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["qualifiers"]:(val)
  }
  #SETL json["modelType"]:("")
  #Qualifiable
  #HasDataSpecification
  ##missing
  #HasDataSpecification
  #SubmodelElement
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("first") json:val
  ERROR_IF_EMPTY_M val:(val) objid:(objid) desc:("first on RelationshipElement")
  SETL json["first"]:(val)
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("second") json:val
  ERROR_IF_EMPTY_M val:(val) objid:(objid) desc:("second on RelationshipElement")
  SETL json["second"]:(val)
  #RelationshipElement_abstract
  SETL json["modelType"]:("RelationshipElement")
}
PROCEDURE global PROCESS_ANNOTATEDRELATIONSHIPELEMENT_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("AnnotatedRelationshipElement") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #RelationshipElement_abstract
  #SubmodelElement
  #Referable
  #HasExtensions
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("extension") records:({"extension": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["extensions"]:(val)
  }
  #HasExtensions
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("category") as-string
  IF (LEN val > 0) {
    SETL json["category"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("idShort") as-string
  IF (LEN val > 0) {
    SETL json["idShort"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("displayName") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["displayName"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("description") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["description"]:(val)
  }
  #Referable
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  #Qualifiable
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("qualifier") records:({"qualifier": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["qualifiers"]:(val)
  }
  #SETL json["modelType"]:("")
  #Qualifiable
  #HasDataSpecification
  ##missing
  #HasDataSpecification
  #SubmodelElement
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("first") json:val
  ERROR_IF_EMPTY_M val:(val) objid:(objid) desc:("first on RelationshipElement")
  SETL json["first"]:(val)
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("second") json:val
  ERROR_IF_EMPTY_M val:(val) objid:(objid) desc:("second on RelationshipElement")
  SETL json["second"]:(val)
  #RelationshipElement_abstract
  
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("dataElement") records:({"dataElement": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["annotations"]:(val)
  }
  SETL json["modelType"]:("AnnotatedRelationshipElement")
}
PROCEDURE global PROCESS_PROPERTY_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("Property") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #DataElement
  #SubmodelElement
  #Referable
  #HasExtensions
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("extension") records:({"extension": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["extensions"]:(val)
  }
  #HasExtensions
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("category") as-string
  IF (LEN val > 0) {
    SETL json["category"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("idShort") as-string
  IF (LEN val > 0) {
    SETL json["idShort"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("displayName") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["displayName"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("description") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["description"]:(val)
  }
  #Referable
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  #Qualifiable
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("qualifier") records:({"qualifier": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["qualifiers"]:(val)
  }
  #SETL json["modelType"]:("")
  #Qualifiable
  #HasDataSpecification
  ##missing
  #HasDataSpecification
  #SubmodelElement
  #DataElement
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("valueType") as-string
  ERROR_IF_EMPTY val:(val) objid:(objid) desc:("valueType on Property")
  SETL json["valueType"]:(val)
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("value") as-string
  IF (LEN val > 0) {
    SETL json["value"]:(val)
  }
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("valueId") json:val
  IF (LEN val > 0) {
    SETL json["valueId"]:(val)
  }
  SETL json["modelType"]:("Property")
}
PROCEDURE global PROCESS_MULTILANGUAGEPROPERTY_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("MultiLanguageProperty") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #DataElement
  #SubmodelElement
  #Referable
  #HasExtensions
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("extension") records:({"extension": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["extensions"]:(val)
  }
  #HasExtensions
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("category") as-string
  IF (LEN val > 0) {
    SETL json["category"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("idShort") as-string
  IF (LEN val > 0) {
    SETL json["idShort"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("displayName") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["displayName"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("description") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["description"]:(val)
  }
  #Referable
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  #Qualifiable
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("qualifier") records:({"qualifier": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["qualifiers"]:(val)
  }
  #SETL json["modelType"]:("")
  #Qualifiable
  #HasDataSpecification
  ##missing
  #HasDataSpecification
  #SubmodelElement
  #DataElement
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("value") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["value"]:(val)
  }
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("valueId") json:val
  IF (LEN val > 0) {
    SETL json["valueId"]:(val)
  }
  SETL json["modelType"]:("MultiLanguageProperty")
}
PROCEDURE global PROCESS_RANGE_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("Range") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #DataElement
  #SubmodelElement
  #Referable
  #HasExtensions
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("extension") records:({"extension": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["extensions"]:(val)
  }
  #HasExtensions
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("category") as-string
  IF (LEN val > 0) {
    SETL json["category"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("idShort") as-string
  IF (LEN val > 0) {
    SETL json["idShort"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("displayName") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["displayName"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("description") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["description"]:(val)
  }
  #Referable
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  #Qualifiable
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("qualifier") records:({"qualifier": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["qualifiers"]:(val)
  }
  #SETL json["modelType"]:("")
  #Qualifiable
  #HasDataSpecification
  ##missing
  #HasDataSpecification
  #SubmodelElement
  #DataElement
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("valueType") as-string
  ERROR_IF_EMPTY val:(val) objid:(objid) desc:("valueType on Range")
  SETL json["valueType"]:(val)
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("min") as-string
  IF (LEN val > 0) {
    SETL json["min"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("max") as-string
  IF (LEN val > 0) {
    SETL json["max"]:(val)
  }
  SETL json["modelType"]:("Range")
}
PROCEDURE global PROCESS_BLOB_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("Blob") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #DataElement
  #SubmodelElement
  #Referable
  #HasExtensions
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("extension") records:({"extension": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["extensions"]:(val)
  }
  #HasExtensions
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("category") as-string
  IF (LEN val > 0) {
    SETL json["category"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("idShort") as-string
  IF (LEN val > 0) {
    SETL json["idShort"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("displayName") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["displayName"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("description") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["description"]:(val)
  }
  #Referable
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  #Qualifiable
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("qualifier") records:({"qualifier": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["qualifiers"]:(val)
  }
  #SETL json["modelType"]:("")
  #Qualifiable
  #HasDataSpecification
  ##missing
  #HasDataSpecification
  #SubmodelElement
  #DataElement
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("value") as-string #should be B64
  IF (LEN val > 0) {
    SETL json["value"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("contentType") as-string
  ERROR_IF_EMPTY val:(val) objid:(objid) desc:("contentType on Blob")
  SETL json["contentType"]:(val)
  SETL json["modelType"]:("Blob")
}
PROCEDURE global PROCESS_FILE_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("File") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #DataElement
  #SubmodelElement
  #Referable
  #HasExtensions
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("extension") records:({"extension": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["extensions"]:(val)
  }
  #HasExtensions
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("category") as-string
  IF (LEN val > 0) {
    SETL json["category"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("idShort") as-string
  IF (LEN val > 0) {
    SETL json["idShort"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("displayName") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["displayName"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("description") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["description"]:(val)
  }
  #Referable
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  #Qualifiable
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("qualifier") records:({"qualifier": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["qualifiers"]:(val)
  }
  #SETL json["modelType"]:("")
  #Qualifiable
  #HasDataSpecification
  ##missing
  #HasDataSpecification
  #SubmodelElement
  #DataElement
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("value") as-string #should be url
  IF (LEN val > 0) {
    SETL json["value"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("contentType") as-string
  ERROR_IF_EMPTY val:(val) objid:(objid) desc:("contentType on File")
  SETL json["contentType"]:(val)
  SETL json["modelType"]:("File")
}
PROCEDURE global PROCESS_REFERENCEELEMENT_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("ReferenceElement") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #DataElement
  #SubmodelElement
  #Referable
  #HasExtensions
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("extension") records:({"extension": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["extensions"]:(val)
  }
  #HasExtensions
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("category") as-string
  IF (LEN val > 0) {
    SETL json["category"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("idShort") as-string
  IF (LEN val > 0) {
    SETL json["idShort"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("displayName") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["displayName"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("description") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["description"]:(val)
  }
  #Referable
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  #Qualifiable
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("qualifier") records:({"qualifier": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["qualifiers"]:(val)
  }
  #SETL json["modelType"]:("")
  #Qualifiable
  #HasDataSpecification
  ##missing
  #HasDataSpecification
  #SubmodelElement
  #DataElement
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("value") json:val
  IF (LEN val > 0 ) {
    SETL json["value"]:(val)
  }
  SETL json["modelType"]:("ReferenceElement")
}
PROCEDURE global PROCESS_SUBMODELELEMENTLIST_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("SubmodelElementList") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #SubmodelElement
  #Referable
  #HasExtensions
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("extension") records:({"extension": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["extensions"]:(val)
  }
  #HasExtensions
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("category") as-string
  IF (LEN val > 0) {
    SETL json["category"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("idShort") as-string
  IF (LEN val > 0) {
    SETL json["idShort"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("displayName") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["displayName"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("description") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["description"]:(val)
  }
  #Referable
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  #Qualifiable
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("qualifier") records:({"qualifier": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["qualifiers"]:(val)
  }
  #SETL json["modelType"]:("")
  #Qualifiable
  #HasDataSpecification
  ##missing
  #HasDataSpecification
  #SubmodelElement
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("orderRelevant") as-string
  IF (LEN val > 0) {
    SETL json["orderRelevant"]:("__" + val) #on stringify replace all "__True" with true and "__False" with false
  }
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticIdListElement") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticIdListElement"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("typeValueListElement") as-string
  ERROR_IF_EMPTY val:(val) objid:(objid) desc:("typeValueListElement on SubmodelElementList")
  SETL json["typeValueListElement"]:(val)
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("valueTypeListElement") as-string
  IF (LEN val > 0) {
    SETL json["valueTypeListElement"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("value") records:({"submodelElement": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["value"]:(val)
  }
  SETL json["modelType"]:("SubmodelElementList")
}
PROCEDURE global PROCESS_CAPABILITY_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("Capability") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #SubmodelElement
  #Referable
  #HasExtensions
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("extension") records:({"extension": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["extensions"]:(val)
  }
  #HasExtensions
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("category") as-string
  IF (LEN val > 0) {
    SETL json["category"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("idShort") as-string
  IF (LEN val > 0) {
    SETL json["idShort"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("displayName") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["displayName"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("description") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["description"]:(val)
  }
  #Referable
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  #Qualifiable
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("qualifier") records:({"qualifier": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["qualifiers"]:(val)
  }
  #SETL json["modelType"]:("")
  #Qualifiable
  #HasDataSpecification
  ##missing
  #HasDataSpecification
  #SubmodelElement
  SETL json["modelType"]:("Capability")
}
PROCEDURE global PROCESS_SUBMODELELEMENTCOLLECTION_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("SubmodelElementCollection") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #SubmodelElement
  #Referable
  #HasExtensions
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("extension") records:({"extension": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["extensions"]:(val)
  }
  #HasExtensions
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("category") as-string
  IF (LEN val > 0) {
    SETL json["category"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("idShort") as-string
  IF (LEN val > 0) {
    SETL json["idShort"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("displayName") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["displayName"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("description") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["description"]:(val)
  }
  #Referable
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  #Qualifiable
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("qualifier") records:({"qualifier": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["qualifiers"]:(val)
  }
  #SETL json["modelType"]:("")
  #Qualifiable
  #HasDataSpecification
  ##missing
  #HasDataSpecification
  #SubmodelElement
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("value") records:({"submodelElement": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["value"]:(val)
  }
  SETL json["modelType"]:("SubmodelElementCollection")
}
PROCEDURE global PROCESS_OPERATION_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("Operation") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #SubmodelElement
  #Referable
  #HasExtensions
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("extension") records:({"extension": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["extensions"]:(val)
  }
  #HasExtensions
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("category") as-string
  IF (LEN val > 0) {
    SETL json["category"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("idShort") as-string
  IF (LEN val > 0) {
    SETL json["idShort"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("displayName") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["displayName"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("description") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["description"]:(val)
  }
  #Referable
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  #Qualifiable
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("qualifier") records:({"qualifier": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["qualifiers"]:(val)
  }
  #SETL json["modelType"]:("")
  #Qualifiable
  #HasDataSpecification
  ##missing
  #HasDataSpecification
  #SubmodelElement
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("inputVariable") records:({"operationVariable": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["inputVariables"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("outputVariable") records:({"operationVariable": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["outputVariables"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("inoutputVariable") records:({"operationVariable": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["inoutputVariables"]:(val)
  }
  SETL json["modelType"]:("Operation")
}
PROCEDURE global PROCESS_OPERATIONVARIABLE_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("OperationVariable") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("value") json:val
  ERROR_IF_EMPTY_M val:(val) objid:(objid) desc:("value on OperationVariable")
  SETL json["value"]:(val)
}
PROCEDURE global PROCESS_ENTITY_JSON objid:integer json:reference {
  ERROR_IF_WRONG_CLASS classname:("Entity") objid:(objid)
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #SubmodelElement
  #Referable
  #HasExtensions
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("extension") records:({"extension": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["extensions"]:(val)
  }
  #HasExtensions
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("category") as-string
  IF (LEN val > 0) {
    SETL json["category"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("idShort") as-string
  IF (LEN val > 0) {
    SETL json["idShort"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("displayName") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["displayName"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("description") records:({"language": { "type": "string", "required": "true" }, "text": { "type": "string", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["description"]:(val)
  }
  #Referable
  #HasSemantics
  GET_INTERREF_ATTRIBUTE_JSON objid:(objid) attrname:("semanticId") json:val
  IF (LEN val > 0 ) {
    SETL json["semanticId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("supplementalSemanticId") records:({"reference": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["supplementalSemanticIds"]:(val)
  }
  #HasSemantics
  #Qualifiable
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("qualifier") records:({"qualifier": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["qualifiers"]:(val)
  }
  #SETL json["modelType"]:("")
  #Qualifiable
  #HasDataSpecification
  ##missing
  #HasDataSpecification
  #SubmodelElement
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("statement") records:({"submodelElement": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["statements"]:(val)
  }
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("entityType") as-string
  ERROR_IF_EMPTY val:(val) objid:(objid) desc:("entityType on Entity")
  SETL json["entityType"]:(val)
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:("globalAssetId") as-string
  IF (LEN val > 0) {
    SETL json["globalAssetId"]:(val)
  }
  GET_RECORD_ATTRIBUTE_JSON objid:(objid) attrname:("specificAssetId") records:({"specificAssetId": { "type": "reference", "required": "true" }}) jsonArray:val
  IF (LEN val > 0) {
    SETL json["specificAssetIds"]:(val)
  }
  SETL json["modelType"]:("Entity")
}



#records = {"myrowattribute": { "type": "reference", "required": "true" }}
PROCEDURE global GET_RECORD_ATTRIBUTE_JSON objid:integer attrname:string records:map jsonArray:reference {
  SETL jsonArray:(array(0))
  CC "Core" GET_CLASS_ID objid:(objid)
  CC "Core" GET_ATTR_ID classid:(classid) attrname:(attrname) #attrid
  CC "Core" GET_REC_ATTR_ROW_COUNT objid:(objid) attrid:(attrid) #count
  SETL row_count:(count)
  SETL row_attrid:(attrid)
  SETL row_objid:(objid)
  FOR row_i from:1 to:(row_count) {
    CC "Core" GET_REC_ATTR_ROW_ID objid:(row_objid) attrid:(row_attrid) index:(row_i) #rowid
    #CC "Core" debug GET_OBJ_NAME objid:(objid)
    #CC "Core" debug GET_ATTR_NAME attrid:(attrid)
    SETL record_rowid:(rowid)
    SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
    SETL dummy: (merase (json, "dummy"))

    FOR record_i from:(0) to:(LEN records - 1) {
      SETL record_attributename:(records.key(record_i))
      SETL record_type:(records[record_attributename, "type"])
      SETL record_required:(records[record_attributename, "required"])
      IF (record_type != "reference") {
        CC "Core" GET_ATTR_VAL objid:(record_rowid) attrname:(record_attributename) as-string #val
      } ELSE {
        GET_INTERREF_ATTRIBUTE_JSON objid:(record_rowid) attrname:(record_attributename) json:val
      }
      IF (record_required = "true") {
        IF (record_type != "reference") {
          ERROR_IF_EMPTY val:(val) objid:(row_objid) desc:(record_attributename + " on " + attrname)
        } ELSE {
          ERROR_IF_EMPTY_M val:(val) objid:(row_objid) desc:(record_attributename + " on " + attrname)
        }
      }
      IF (LEN val > 0) {
        SETL json[record_attributename]:(val)
      }
    }
    IF (LEN json > 0) {
      IF (LEN json = 1) {
        SETL dummy:(aappend(jsonArray, json[json.key(0)]))
      } ELSE {
        SETL dummy:(aappend(jsonArray, json))
      }
    }
  }
}


PROCEDURE global GET_INTERREF_ATTRIBUTE_JSON objid:integer attrname:string json:reference {
  GET_INTERREF_OBJECT_ID objid:(objid) attrname:(attrname) sRefModelId:sRefModelId sRefObjId:sRefObjId
  IF (sRefObjId = "") {
    SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
    SETL dummy: (merase (json, "dummy"))
  } ELSE {
    SETL ref_objid:(VAL sRefObjId)
    CC "Core" GET_CLASS_ID objid:(ref_objid)
    CC "Core" GET_CLASS_NAME classid:(classid) #classname
    IF (classname = "AssetAdministrationShell") {
      PROCESS_ASSETADMINISTRATIONSHELL_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "Submodel") {
      PROCESS_SUBMODEL_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "ConceptDescription") {
      PROCESS_CONCEPTDESCRIPTION_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "Reference") {
      PROCESS_REFERENCE_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "Extension") {
      PROCESS_EXTENSION_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "SpecificAssetId") {
      PROCESS_SPECIFICASSETID_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "DataSpecification") {
      PROCESS_DATASPECIFICATION_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "Qualifier") {
      PROCESS_QUALIFIER_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "RelationshipElement") {
      PROCESS_RELATIONSHIPELEMENT_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "AnnotatedRelationshipElement") {
      PROCESS_ANNOTATEDRELATIONSHIPELEMENT_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "Property") {
      PROCESS_PROPERTY_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "MultiLanguageProperty") {
      PROCESS_MULTILANGUAGEPROPERTY_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "Range") {
      PROCESS_RANGE_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "Blob") {
      PROCESS_BLOB_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "File") {
      PROCESS_FILE_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "ReferenceElement") {
      PROCESS_REFERENCEELEMENT_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "SubmodelElementList") {
      PROCESS_SUBMODELELEMENTLIST_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "Capability") {
      PROCESS_CAPABILITY_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "SubmodelElementCollection") {
      PROCESS_SUBMODELELEMENTCOLLECTION_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "Operation") {
      PROCESS_OPERATION_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "OperationVariable") {
      PROCESS_OPERATIONVARIABLE_JSON objid:(ref_objid) json:json
    } ELSIF (classname = "Entity") {
      PROCESS_ENTITY_JSON objid:(ref_objid) json:json
    } ELSE {
      CC "AdoScript" ERRORBOX ("CLASS NOT VALID: " + classname + ", Object " +  STR(ref_objid))
      EXIT
    }
  }
}

PROCEDURE global ERROR_IF_WRONG_CLASS classname:string objid:integer {
  CC "Core" GET_CLASS_ID classname:(classname)
  SETL expectedClassId:(classid)
  CC "Core" GET_CLASS_ID objid:(objid)
  IF (classid != expectedClassId) {
    CC "AdoScript" ERRORBOX ("WRONG FUNCTION USED: Object " +  STR(objid) + " is not of class " + classname)
    EXIT
  }
}

PROCEDURE global ERROR_IF_EMPTY val:string desc:string objid:integer { #valid for string, array, maps
  IF (LEN val = 0) {
    CC "AdoScript" ERRORBOX ("Missing required attribute value: " + desc + ", object " + STR(objid))
    EXIT
  }
}
PROCEDURE global ERROR_IF_EMPTY_A val:array desc:string objid:integer { #valid for string, array, maps
  IF (LEN val = 0) {
    CC "AdoScript" ERRORBOX ("Missing required attribute value: " + desc + ", object " + STR(objid))
    EXIT
  }
}
PROCEDURE global ERROR_IF_EMPTY_M val:map desc:string objid:integer { #valid for string, array, maps
  IF (LEN val = 0) {
    CC "AdoScript" ERRORBOX ("Missing required attribute value: " + desc + ", object " + STR(objid))
    EXIT
  }
}

PROCEDURE global GET_INTERREF_OBJECT_ID objid:integer attrname:string sRefModelId: reference sRefObjId: reference {
  SETL sRefModelId:("")
  SETL sRefObjId:("")
  CC "Core" GET_ATTR_VAL objid:(objid) attrname:(attrname) as-string
  IF (val != "") {
    CC "Core" GET_ATTR_VAL objid:(objid) attrname:(attrname) format:("%m") #val
    SETL sRefModelName:(val)
    CC "Core" GET_ATTR_VAL objid:(objid) attrname:(attrname) format:("%t") #val
    SETL sRefModelType:(val)
    CC "Core" GET_ATTR_VAL objid:(objid) attrname:(attrname) format:("%o") #val
    SETL sRefObjName:(val)
    CC "Core" GET_ATTR_VAL objid:(objid) attrname:(attrname) format:("%c") #val
    SETL sRefObjClassName:(val)
    CC "Core" GET_MODEL_ID modelname:(sRefModelName) modeltype:(sRefModelType)
    SETL nRefModelId:(modelid)
    CC "Core" IS_MODEL_LOADED modelid:(nRefModelId)
    IF (isloaded = 0) {
      CC "Core" LOAD_MODEL modelid:(nRefModelId)
    }
    CC "Core" GET_CLASS_ID classname:(sRefObjClassName)
    CC "Core" GET_OBJ_ID modelid:(nRefModelId) classid:(classid) objname:(sRefObjName)
    SETL nRefObjId:(objid)
    SETL sRefModelId: (STR nRefModelId)
    SETL sRefObjId: (STR nRefObjId)
  }
}

PROCEDURE global VALIDATE_AAS aas:string result:reference {
  CC "AdoScript" GET_TEMP_FILENAME
  SETL sSchemaFilePath:(filename + "-aas-schema.json")
  SETL sInstanceFilePath:(filename + "-aas-instance.json")
  SETL sResultsFilePath:(filename + "-aas-results.log")
  CC "AdoScript" FWRITE file: (sInstanceFilePath) text: (aas) append: 0 binary: 0 base64: 0
  CC "AdoScript" FILE_COPY from:("db:\\aas.json") to:(sSchemaFilePath)
  SETL sTransformationCommand:("tools\\json-schema-validator-cli.exe \"" + sSchemaFilePath + "\" \"" + sInstanceFilePath+ "\" \"" + sResultsFilePath + "\"")
  #SYSTEM ("cmd /c " + sTransformationCommand) with-console-window
  SYSTEM (sTransformationCommand)
  #CC "AdoScript" VIEWBOX text:(sTransformationCommand)
  CC "AdoScript" FREAD file: (sResultsFilePath)
  SETL result:(text)
  #CC "AdoScript" VIEWBOX text:(result)
  CC "AdoScript" FILE_DELETE file: (sSchemaFilePath)
  CC "AdoScript" FILE_DELETE file: (sInstanceFilePath)
  CC "AdoScript" FILE_DELETE file: (sResultsFilePath)
}






PROCEDURE global EXPORT_DATA_BINDING_JSON {
  CC "ImportExport" SHOW_EXPORT_DLG multi-select:0 mode: "json" title: "Select the Models to export" filedescription: "json format" fileextension: "*.json"
  IF (endbutton != "ok") {
    EXIT
  }
  SETL sExportPath:(filename)
  
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  #TODO: finish this

  SETL sJSON:(mapToJson(json))
  SETL sJSON:(replall(sJSON, "\"__True\"", "true"))
  SETL sJSON:(replall(sJSON, "\"__False\"", "false"))
  CC "AdoScript" FWRITE file:(sExportPath) text:(sJSON) append:0 binary:0 base64:0
  CC "AdoScript" INFOBOX "Export Completed"
}

PROCEDURE global PUBLISH_SERVICES_BINDING {
  CC "CoreUI" MODEL_SELECT_BOX oktext:("Export") boxtext:("Select the Binding Model to publish") title:("Publish Services Binding")
  IF (endbutton != "ok") {
    EXIT
  }
  CC "Core" GET_MODEL_INFO modelid:(VAL modelids)
  IF (NOT (modeltype = "Data Binding Model")) {
    CC "AdoScript" ERRORBOX ("The Service Binding publishing is available only for 'Data Binding Model' model type. Selected model type: " + modeltype)
    EXIT
  }

  SETL dtmanagerBaseUrl:(modaptoProperties["dtmanagerBaseUrl"])
  GENERATE_AUTHORIZATION_HEADER headersMap:headersMap
  SETL headersMap["Content-Type"]:("application/json")

  CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(VAL modelids) classname:"AAS Reference"
  FOR sAASReferenceId in:(objids) {
    GET_INTERREF_OBJECT_ID objid:(VAL sAASReferenceId) attrname:("Reference") sRefModelId:sRefModelId sRefObjId:sRefObjId
    IF (sRefObjId = "") {
      CC "Core" GET_ATTR_VAL objid:(VAL sAASReferenceId) attrname:("Name") as-string
      CC "AdoScript" ERRORBOX ("Missing AAS Reference on " + val)
      EXIT
    }
    CC "Core" IS_MODEL_LOADED modelid:(VAL sRefModelId)
    IF (isloaded = 0) {
      CC "Core" LOAD_MODEL modelid:(VAL sRefModelId)
    }
    CC "Core" GET_ATTR_VAL objid:(VAL sRefObjId) attrname:("publishId") as-string
    SETL sPublishId:(val)
    IF (sPublishId = "") {
      CC "Core" GET_ATTR_VAL objid:(VAL sAASReferenceId) attrname:("Name") as-string
      CC "AdoScript" ERRORBOX ("The AAS referenced on " + val + " MUST be published")
      EXIT
    }
    CC "Core" EVAL_EXPRESSION (ctobjs(VAL sAASReferenceId, "binding"))
    FOR sServiceObjId in:(result) {
      CC "Core" GET_ATTR_VAL objid:(VAL sServiceObjId) attrname:("Name") as-string
      SETL sServiceName:(val)
      CC "Core" GET_ATTR_VAL objid:(VAL sServiceObjId) attrname:("catalogueId") as-string
      SETL sCatalogueId:(val)
      IF (sCatalogueId = "") {
        CC "AdoScript" ERRORBOX ("Empty catalogueId on service " + sServiceName)
        EXIT
      }
      CC "Core" GET_ATTR_VAL objid:(VAL sServiceObjId) attrname:("publishId") as-string
      IF (val = "") {
        #CC "AdoScript" VIEWBOX text:(sServiceName)
        CC "AdoScript" HTTP_REQUEST (dtmanagerBaseUrl + "/modules/"+sPublishId+"/services") method:("POST") reqheader:(headersMap) reqbody:(mapToJson({"serviceCatalogId":sCatalogueId}))
        IF (ecode <> 0) {
          CC "AdoScript" ERRORBOX (errmsg)
          EXIT
        }
        IF (statuscode < 200 OR statuscode >= 300) {
          CC "AdoScript" ERRORBOX ("HTTP Status Code: " + STR(statuscode) + "\n" + response)
          EXIT
        }
        #CC "AdoScript" VIEWBOX text:(response)
        SETL resp_json:(fromJson(response))
        SETL servicePublishedId:(resp_json["id"])
        CC "Core" SET_ATTR_VAL objid:(VAL sServiceObjId) attrname:("publishId") val:(servicePublishedId) as-string
      }
    }
    CC "Modeling" SAVE modelid:(VAL modelids)
  }
  CC "AdoScript" INFOBOX ("Publish Services Completed")
}

PROCEDURE global PUBLISH_AAS {
  CC "CoreUI" MODEL_SELECT_BOX oktext:("Export") boxtext:("Select the AAS Model to publish") title:("Publish AAS")
  IF (endbutton != "ok") {
    EXIT
  }
  CC "Core" GET_MODEL_INFO modelid:(VAL modelids)
  IF (NOT (modeltype = "Asset Administration Shell Environment")) {
    CC "AdoScript" ERRORBOX ("The AAS publishing is available only for 'Asset Administration Shell Environment' model type. Selected model type: " + modeltype)
    EXIT
  }

  CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(VAL modelids) classname:"AssetAdministrationShell"
  IF (tokcnt(objids) != 1) {
    CC "AdoScript" ERRORBOX ("The selected 'Asset Administration Shell Environment' model MUST contain only 1 AssetAdministrationShell object. Currently " + STR(tokcnt(objids)))
    EXIT
  }
  SETL nAssetAdministrationShellId:(VAL objids)
  CC "Core" GET_ATTR_VAL objid:(nAssetAdministrationShellId) attrname:("publishId") as-string
  SETL sPublishId:(val)
  CC "AdoScript" VIEWBOX text:(sPublishId)

  AAS_GENERATE_JSON nModelId:(VAL modelids) json:json_map
  SETL sJSON:(mapToJson(json_map))
  SETL sJSON:(replall(sJSON, "\"__True\"", "true"))
  SETL sJSON:(replall(sJSON, "\"__False\"", "false"))
  #CC "AdoScript" VIEWBOX text:(sJSON)
  VALIDATE_AAS aas:(sJSON) result:validationResult
  IF (validationResult != "ok") {
    CC "AdoScript" ERRORBOX ("AAS Validation Error:\n" + validationResult)
    EXIT
  }
  
  SETL dtmanagerBaseUrl:(modaptoProperties["dtmanagerBaseUrl"])
  SETL sJSONB64:(base64encode(sJSON))
  #CC "AdoScript" VIEWBOX text:(sJSONB64)
  GENERATE_AUTHORIZATION_HEADER headersMap:headersMap
  SETL headersMap["Content-Type"]:("application/json")
  IF (sPublishId = "") {
    CC "AdoScript" HTTP_REQUEST (dtmanagerBaseUrl + "/modules") method:("POST") reqheader:(headersMap) reqbody:(mapToJson({"aas":sJSONB64, "format":"JSON", "type":"DOCKER", "assetConnections":array(0)}))
  } ELSE {
    CC "AdoScript" HTTP_REQUEST (dtmanagerBaseUrl + "/modules/"+sPublishId) method:("PUT") reqheader:(headersMap) reqbody:(mapToJson({"aas":sJSONB64, "format":"JSON", "type":"DOCKER", "assetConnections":array(0)}))
  }
  IF (ecode <> 0) {
    CC "AdoScript" ERRORBOX (errmsg)
    EXIT
  }
  IF (statuscode < 200 OR statuscode >= 300) {
    CC "AdoScript" ERRORBOX ("HTTP Status Code: " + STR(statuscode) + "\n" + response)
    EXIT
  }
  CC "AdoScript" VIEWBOX text:(response)
  SETL resp_json:(fromJson(response))
  SETL aasId:(resp_json["id"])
  #SETL aasId:("TEST-ID")
  
  CC "Core" SET_ATTR_VAL objid:(nAssetAdministrationShellId) attrname:("publishId") val:(aasId) as-string
  CC "Modeling" SAVE modelid:(VAL modelids)

  CC "AdoScript" INFOBOX ("Publish Completed with ID: " + aasId)
}

PROCEDURE global PUBLISH_BPMN {
  CC "CoreUI" MODEL_SELECT_BOX oktext:("Export") boxtext:("Select the BPMN to publish") title:("Publish BPMN")
  IF (endbutton != "ok") {
    EXIT
  }
  CC "Core" GET_MODEL_INFO modelid:(VAL modelids)
  IF (NOT (modeltype = "Business process diagram (BPMN 2.0)" OR modeltype = "Business Process Diagram (BPMN 2.0)")) {
    CC "AdoScript" ERRORBOX ("The BPMN export is available only for 'Business process diagram (BPMN 2.0)' model type. Selected model type: " + modeltype)
    EXIT
  }
  GET_BPMN modelid:(modelids) bpmn:bpmn
  #CC "AdoScript" VIEWBOX text:(bpmn)
  IF (bpmn = "") {
    CC "AdoScript" ERRORBOX ("Error during the BPMN generation")
    EXIT
  }
  
  GENERATE_AUTHORIZATION_HEADER headersMap:headersMap
  CC "AdoScript" HTTP_REQUEST (mscBaseEndpoint + "/micro-service-controller-rest/rest/msc/callMicroserviceCustomIO/92d44336-4d0f-42cd-a944-8611b3cc4aa6/uploadSchema/bpmn") method:("POST") reqheader:(headersMap) reqbody:(bpmn)
  IF (ecode <> 0) {
    CC "AdoScript" ERRORBOX (errmsg)
    EXIT
  }
  IF (statuscode < 200 OR statuscode >= 300) {
    CC "AdoScript" ERRORBOX ("HTTP Status Code: " + STR(statuscode) + "\n" + response)
    EXIT
  }
  #CC "AdoScript" VIEWBOX text:(response)
  SETL resp_json:(fromJson(response))
  IF (type(resp_json["error"]) != "undefined") {
    CC "AdoScript" ERRORBOX (auth_json["error_description"])
    EXIT
  }
  SETL fileId:(resp_json["fileId"])
  SETL kafkaEndpoint:(modaptoProperties["kafkaEndpoint"])
  CC "AdoScript" HTTP_REQUEST (mscBaseEndpoint + "/micro-service-controller-rest/rest/msc/callMicroserviceCustomIO/92d44336-4d0f-42cd-a944-8611b3cc4aa6/orchestrated?fileId="+encodeuri(fileId)+"&kafkaEndpoint="+encodeuri(kafkaEndpoint)) reqheader:(headersMap)
  IF (ecode <> 0) {
    CC "AdoScript" ERRORBOX (errmsg)
    EXIT
  }
  IF (statuscode < 200 OR statuscode >= 300) {
    CC "AdoScript" ERRORBOX ("HTTP Status Code: " + STR(statuscode) + "\n" + response)
    EXIT
  }
  #CC "AdoScript" VIEWBOX text:(response)
  CC "AdoScript" INFOBOX "Publish Completed"
}