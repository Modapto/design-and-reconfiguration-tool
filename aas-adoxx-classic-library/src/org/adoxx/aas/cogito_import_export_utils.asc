##TODO
# import: CHECK RESOURCES?

PROCEDURE global GET_INTERREF_OBJECT_ID nObjId: integer sAttributeName: string sRefModelId: reference sRefObjId: reference {
  SETL sRefModelId:("")
  SETL sRefObjId:("")
  CC "Core" GET_ATTR_VAL objid:(nObjId) attrname:(sAttributeName) as-string
  IF (val != "") {
    CC "Core" GET_ATTR_VAL objid:(nObjId) attrname:(sAttributeName) format:("%m") #val
    SETL sRefModelName:(val)
    CC "Core" GET_ATTR_VAL objid:(nObjId) attrname:(sAttributeName) format:("%t") #val
    SETL sRefModelType:(val)
    CC "Core" GET_ATTR_VAL objid:(nObjId) attrname:(sAttributeName) format:("%o") #val
    SETL sRefObjName:(val)
    CC "Core" GET_ATTR_VAL objid:(nObjId) attrname:(sAttributeName) format:("%c") #val
    SETL sRefObjClassName:(val)
    CC "Core" GET_MODEL_ID modelname:(sRefModelName) modeltype:(sRefModelType)
    SETL nRefModelId:(modelid)
    CC "Core" IS_MODEL_LOADED modelid:(nRefModelId)
    IF (isloaded = 0) {
      CC "Core" LOAD_MODEL modelid:(nRefModelId)
    }
    CC "Core" GET_CLASS_ID classname:(sRefObjClassName)
    CC "Core" GET_OBJ_ID modelid:(nRefModelId) classid:(classid) objname:(sRefObjName)
    SETL nRefObjId:(objid)
    SETL sRefModelId: (STR nRefModelId)
    SETL sRefObjId: (STR nRefObjId)
  }
}
PROCEDURE global COGITO_IMPORT_NEW sJSON: string sModelname: string sModelGroup: string {
  COGITO_IMPORT_MAP json_map:(fromJson(sJSON)) sModelname:(sModelname) sModelGroup:(sModelGroup) nFilterEl:(0)
}
PROCEDURE global COGITO_IMPORT_MAP json_map: map sModelname: string sModelGroup: string nFilterEl:integer {
  CC "Core" GET_MODELGROUP_ID mgroupname:(sModelGroup) sep:"\t"
  CC "Core" CREATE_MODEL  modeltype:("Business Process Diagram (BPMN 2.0)") modelname:(sModelname + " - BPMN") version:("1.0") mgroups:(STR mgroupid)
  IF (ecode != 0) {
    CC "AdoScript" ERRORBOX (errtext)
    EXIT
  }
  SETL nModelIdBPMN:(modelid)
  CC "Core" CREATE_MODEL  modeltype:("Resources") modelname:(sModelname + " - RES") version:("1.0") mgroups:(STR mgroupid)
  IF (ecode != 0) {
    CC "AdoScript" ERRORBOX (errtext)
    EXIT
  }
  SETL nModelIdRES:(modelid)

  CC "Core" LOAD_MODEL modelid:(nModelIdBPMN)
  CC "Core" LOAD_MODEL modelid:(nModelIdRES)

  CC "Modeling" OPEN modelids:(nModelIdRES)

  #SETL json_map:(fromJson(sJSON))

  #FILL RES
  SETL resources:(json_map["resources"])
  IF (type(resources) = "undefined") {
    SETL resources:(json_map["roles"])
    IF (type(resources) = "undefined") {
      SETL resources:({"dummy":"dummy_is_a_map_not_an_array"})
      SETL dummy: (merase (resources, "dummy"))
    }
  }
  SETL resource_map:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (resource_map, "dummy"))

  FOR i from:(0) to:(LEN resources - 1) {
    SETL resources_id:(resources.key(i))
    SETL resource:(resources[resources_id])
    IF (type(resource) != "map") {
      NEXT
    }
    SETL resource_name:(resource["name"])
    SETL resource_type:(resource["type"])
    SETL resource_quantity:(resource["quantity"])
    SETL resource_cost_per_hour:(resource["cost_per_hour"])

    CC "Core" GET_CLASS_ID classname:"Resource"
    CC "Core" CREATE_OBJ modelid:(nModelIdRES) classid:(classid) objname:(resource_name)
    IF (ecode != 0) {
      CC "AdoScript" ERRORBOX (errtext)
      EXIT
    }
    SETL nObjId:(objid)
    CC "Modeling" SET_OBJ_POS objid:(nObjId) x:(2cm + (i MOD 5)*4cm) y:(CEIL((i+1) / 5)*4cm - 2cm)

    CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("ID") val:(resources_id) as-string
    CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("Type") val:(resource_type) as-string
    CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("Quantity") val:(resource_quantity) as-string
    CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("Cost_per_Hour") val:(resource_cost_per_hour) as-string
    SETL resource_map[resources_id]:(nObjId)
  }
  CC "Modeling" SAVE modelid:(nModelIdRES)


  CC "Modeling" OPEN modelids:(nModelIdBPMN)
  
  CC "AdoScript" GET_TEMP_FILENAME
  CC "AdoScript" FWRITE file:(filename+".json") text:(mapToJson(json_map)) append: 0 binary: 0 base64: 0
  CC "Core" SET_ATTR_VAL objid:(nModelIdBPMN) attrname:("Original JSON") val:(filename+".json") as-string
  SETL project_id:(json_map["project_id"])
  CC "Core" SET_ATTR_VAL objid:(nModelIdBPMN) attrname:("Project Id") val:(project_id) as-string
  SETL project_name:(json_map["project_name"])
  CC "Core" SET_ATTR_VAL objid:(nModelIdBPMN) attrname:("Project Name") val:(project_name) as-string

  SETL elements:(json_map["elements"])
  SETL zones:(json_map["zones"])
  SETL tasks:(json_map["tasks"])

  #find unassigned elements
  SETL unassigned_elements_list:({})
  SETL assigned_elements_list:({})
  FOR i from:(0) to:(LEN tasks - 1) {
    SETL tasks_id:(tasks.key(i))
    SETL task:(tasks[tasks_id])
    SETL task_element_list:(cond(type(task["elements_list"]) != "undefined", task["elements_list"], task["element_list"]))
    IF (type(task_element_list) != "undefined") {
      FOR task_element_list_i from:(0) to:(LEN task_element_list - 1) {
        SETL task_element:(task_element_list[task_element_list_i])
        SETL task_element_id:("")
        IF (type(task_element) = "string") {
          SETL task_element_id:(task_element)
        } ELSE {
          SETL task_element_id:(task_element["element_id"])
        }
        IF (NOT (task_element_id IN assigned_elements_list)) {
          SETL dummy:(aappend(assigned_elements_list, task_element_id))
        }
      }
    }
  }
  FOR i from:(0) to:(LEN elements - 1) {
    SETL elements_id:(elements.key(i))
    IF (NOT (elements_id IN assigned_elements_list)) {
      SETL dummy:(aappend(unassigned_elements_list, elements_id))
    }
  }
  #CC "AdoScript" INFOBOX ("unassegned elements: " + STR LEN unassigned_elements_list)

  FOR i from:(0) to:(LEN tasks - 1) {
    SETL tasks_id:(tasks.key(i))
    SETL task:(tasks[tasks_id])
    SETL sub_task_list:(task["sub_task_list"])
    IF (type(sub_task_list) != "undefined") {
      IF (LEN sub_task_list > 0) {
        NEXT
      }
    }
    SETL task_name:(task["name"])

    CC "Core" GET_CLASS_ID classname:"Sub-Process (BPMN)"
    CC "Core" CREATE_OBJ modelid:(nModelIdBPMN) classid:(classid) objname:(tasks_id + "-" + task_name)
    IF (ecode != 0) {
      CC "AdoScript" ERRORBOX (errtext)
      EXIT
    }
    SETL nObjId:(objid)
    CC "Modeling" SET_OBJ_POS objid:(nObjId) x:(2cm + (i MOD 5)*4cm) y:(CEIL((i+1) / 5)*4cm - 2cm)

    CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("Task Id") val:(tasks_id) as-string

    SETL task_parent_task:(task["parent_task"])
    CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("Parent Task Id") val:(task_parent_task) as-string

    SETL task_start_date:(cond(type(task["start_date"])!="undefined", task["start_date"], task["start_time"]))
    CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("Start Date") val:(task_start_date) as-string

    SETL task_end_date:(cond(type(task["end_date"])!="undefined", task["end_date"], task["end_time"]))
    CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("End Date") val:(task_end_date) as-string


    SETL task_work_quantity:(task["work_quantity"])
    CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("work_quantity") val:(task_work_quantity) as-string

    SETL task_work_quantity_unit:(task["work_quantity_unit"])
    CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("work_quantity_unit") val:(task_work_quantity_unit) as-string
    
    SETL task_type:(cond(type(task["type"]) != "undefined", task["type"], "NORMAL_TASK"))
    CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("COGITO Task Type") val:(task_type) as-string

    SETL task_handle_unassigned_elements:(cond(type(task["handle_unassigned_elements"]) != "undefined", task["handle_unassigned_elements"], "No"))
    CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("Add unassigned elements") val:(task_handle_unassigned_elements) as-string

    SETL task_crew_productivity:(task["crew_productivity"])
    IF (task_crew_productivity = 0) {
      SETL task_crew_productivity:(isoDateToDays(task_end_date) - isoDateToDays(task_start_date) + 1)
      SETL weekendDays:(floor(task_crew_productivity/7)*2)
      SETL task_crew_productivity:((task_crew_productivity-weekendDays) / task_work_quantity)
    }
    CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("crew_productivity") val:(task_crew_productivity)

    SETL task_crew_number:(task["crew_number"])
    IF (task_crew_number = 0) {
      SETL task_crew_number:(1)
    }
    CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("crew_number") val:(task_crew_number)

    SETL task_crew_productivity_penalty:(task["crew_productivity_penalty"])
    IF (task_crew_productivity_penalty = 0) {
      SETL task_crew_productivity_penalty:(1.1)
    }
    CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("crew_productivity_penalty") val:(task_crew_productivity_penalty)

    SETL task_description:(task["description"])
    CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("Description") val:(task_description) as-string

    SETL task_element_list:(cond(type(task["elements_list"]) != "undefined", task["elements_list"], task["element_list"]))
    IF (type(task_element_list) != "undefined") {
      FOR task_element_list_i from:(0) to:(LEN task_element_list - 1) {
        SETL task_element:(task_element_list[task_element_list_i])
        SETL task_element_id:("")
        SETL task_element_action:("")
        IF (type(task_element) = "string") {
          SETL task_element_id:(task_element)
        } ELSE {
          SETL task_element_id:(task_element["element_id"])
          SETL task_element_action:(task_element["action"])
        }

        SETL element:(elements[task_element_id])
        SETL element_name:(element["name"])
        SETL element_type:(element["type"])
        SETL zone_id:(element["zone"])
        SETL zone:(zones[zone_id])
        SETL zone_name:(zone["name"])
        SETL zone_description:(zone["description"])
        SETL zone_type:(zone["type"])
        SETL zone_linked_zones:(zone["linked_zones"])

        #IF (NOT ((task_type = "SAFETY" OR task_type = "SAFETY_ADDED") AND element_type = "SAFETY_ELEMENT" AND (task_element_action = "ADDED" OR task_element_action = ""))) {
        #  NEXT
        #}
        #IF (NOT ((task_type = "SAFETY" OR task_type = "SAFETY_REMOVED") AND element_type = "SAFETY_ELEMENT" AND (task_element_action = "REMOVED" OR task_element_action = ""))) {
        #  NEXT
        #}
        IF (task_type = "SAFETY" OR task_type = "SAFETY_REMOVED" OR task_type = "SAFETY_ADDED") {
          IF (element_type != "SAFETY_ELEMENT") {
            NEXT
          } ELSE {
            IF (task_element_action != "") {
              IF (task_type = "SAFETY_REMOVED" AND task_element_action = "ADDED") {
                NEXT
              }
              IF (task_type = "SAFETY_ADDED" AND task_element_action = "REMOVED") {
                NEXT
              }
            }
          }
        }

        IF (task_type = "GEOMETRIC_QUALITY_CONTROL" OR task_type = "VISUAL_QUALITY_CONTROL" ) {
          IF (element_type = "SAFETY_ELEMENT") {
            NEXT
          }
        }

        IF (nFilterEl = 1 AND task_type = "NORMAL_TASK" AND element_type = "SAFETY_ELEMENT") {
          NEXT
        }

        CC "Core" GET_CLASS_ID objid:(nObjId)
        CC "Core" GET_ATTR_ID classid:(classid) attrname:"Elements"
        CC "Core" ADD_REC_ROW objid:(nObjId) attrid:(attrid)
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("ID") val:(task_element_id) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Element_Name") val:(element_name) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Element_Type") val:(element_type) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Action") val:(task_element_action) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Zone") val:(zone_id) as-string

        CC "Core" GET_CLASS_ID objid:(nObjId)
        CC "Core" GET_ATTR_ID classid:(classid) attrname:"Zones"
        CC "Core" ADD_REC_ROW objid:(nObjId) attrid:(attrid)
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("ID") val:(zone_id) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Zone_Name") val:(zone_name) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Description") val:(zone_description) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Zone_Type") val:(zone_type) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Linked_Zones") val:(zone_linked_zones) as-string
        
      }
    }

    IF (task_handle_unassigned_elements = "Yes") {
      FOR unassigned_elements_list_i from:(0) to:(LEN unassigned_elements_list - 1) {
        SETL task_element_id:(unassigned_elements_list[unassigned_elements_list_i])
        SETL task_element_action:("")

        SETL element:(elements[task_element_id])
        SETL element_name:(element["name"])
        SETL element_type:(element["type"])
        SETL zone_id:(element["zone"])
        SETL zone:(zones[zone_id])
        SETL zone_name:(zone["name"])
        SETL zone_description:(zone["description"])
        SETL zone_type:(zone["type"])
        SETL zone_linked_zones:(zone["linked_zones"])

        IF (task_type = "SAFETY" OR task_type = "SAFETY_REMOVED" OR task_type = "SAFETY_ADDED") {
          IF (element_type != "SAFETY_ELEMENT") {
            NEXT
          }
        }

        IF (task_type = "GEOMETRIC_QUALITY_CONTROL" OR task_type = "VISUAL_QUALITY_CONTROL" ) {
          IF (element_type = "SAFETY_ELEMENT") {
            NEXT
          }
        }

        IF (nFilterEl = 1 AND task_type = "NORMAL_TASK" AND element_type = "SAFETY_ELEMENT") {
          NEXT
        }

        CC "Core" GET_CLASS_ID objid:(nObjId)
        CC "Core" GET_ATTR_ID classid:(classid) attrname:"Elements"
        CC "Core" ADD_REC_ROW objid:(nObjId) attrid:(attrid)
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("ID") val:(task_element_id) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Element_Name") val:(element_name) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Element_Type") val:(element_type) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Action") val:(task_element_action) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Zone") val:(zone_id) as-string

        CC "Core" GET_CLASS_ID objid:(nObjId)
        CC "Core" GET_ATTR_ID classid:(classid) attrname:"Zones"
        CC "Core" ADD_REC_ROW objid:(nObjId) attrid:(attrid)
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("ID") val:(zone_id) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Zone_Name") val:(zone_name) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Description") val:(zone_description) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Zone_Type") val:(zone_type) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Linked_Zones") val:(zone_linked_zones) as-string
        

      }
    }

    SETL task_resource_list:(task["resource_list"])
    IF (type(task_resource_list) != "undefined") {
      FOR task_resource_list_i from:(0) to:(LEN task_resource_list - 1) {
        SETL task_resource:(task_resource_list[task_resource_list_i])
        SETL task_resource_id:(task_resource["resource_id"])
        SETL task_resource_quantity:(task_resource["quantity_needed"])

        CC "Core" GET_CLASS_ID objid:(nObjId)
        CC "Core" GET_ATTR_ID classid:(classid) attrname:"Resources"
        CC "Core" ADD_REC_ROW objid:(nObjId) attrid:(attrid)
        CC "Core" GET_CLASS_ID objid: (rowid)
        CC "Core" GET_ATTR_ID classid: (classid) attrname:"Resource"
        SETL nToObjID:(resource_map[task_resource_id])
        CC "Core" ADD_INTERREF attrid: (attrid) objid: (rowid) tobjid: (nToObjID) tmodelid:(nModelIdRES)
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Quantity") val:(task_resource_quantity) as-string
      }
    }
    
  }


  CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(nModelIdBPMN) classname:"Sub-Process (BPMN)"
  FOR sTaskId in:(objids) {
    SETL n_toobjid:(VAL sTaskId)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Task Id") as-string
    SETL task_id:(val)

    SETL task:(tasks[task_id])
    #CC "AdoScript" VIEWBOX text:(task)
    SETL previous_task_list:(cond(type(task["previous_task_list"]) != "undefined", task["previous_task_list"], {}))
    FOR previous_task_list_i from:(0) to:(LEN previous_task_list - 1) {
      SETL previous_task_id:(previous_task_list[previous_task_list_i])
      SETL previous_task:(tasks[previous_task_id])
      SETL previous_task_name:(previous_task["name"])

      CC "Core" GET_CLASS_ID classname:"Sub-Process (BPMN)"
      CC "Core" GET_OBJ_ID modelid:(nModelIdBPMN) classid:(classid) objname:(previous_task_id + "-" + previous_task_name)
      SETL n_fromobjid:(objid)
      CC "Core" GET_CLASS_ID relation classname:"Subsequent"
      CC "Core" CREATE_CONNECTOR modelid:(nModelIdBPMN) classid:(classid) fromobjid:(n_fromobjid) toobjid:(n_toobjid)
    }
  }
  CC "Modeling" SAVE modelid:(nModelIdBPMN)
  ORDER_MODEL modelid:(nModelIdBPMN)
}



PROCEDURE global UPDATE_START_END_TIMES nModelId:integer start_time:string end_time:string parent_task_name:string {
  #go step by step on the model and update the start and end time of each task splitting the provided start-end times by the duration of each task
  #start_time end_time format: 2009-10-12T08:00:00

  SETL nModelId:(modelid)

  SETL tasks_map:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (tasks_map, "dummy"))
  SETL running_tasks_list:(array(0))
  SETL executed_tasks_list:(array(0))

  #CC "Modeling" OPEN modelids:(nModelId)
  CC "Core" LOAD_MODEL modelid:(nModelId)

  CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(nModelId) classname:"Sub-Process (BPMN)"
  SETL sTaskIdList:(objids)
  FOR sTaskId in:(objids) {
    SETL task_map:({"adoxx_id": sTaskId})
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Task Id") as-string
    SETL task_id:(val)
    SETL task_map["id"]:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Name") as-string
    SETL sTaskName:(val)
    SETL task_map["name"]:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Start Date") as-string
    SETL task_map["start_time"]:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("End Date") as-string
    SETL task_map["end_time"]:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Duration") as-string
    SETL task_map["duration"]:(val) #00:000:00:00:00

    SETL previous_task_list:(array(0))
    CC "AQL" EVAL_AQL_EXPRESSION expr:("({\""+sTaskName+"\":\"Task (BPMN)\"} <- \"Subsequent\") OR ({\""+sTaskName+"\":\"Sub-Process (BPMN)\"} <- \"Subsequent\")") modelid: (nModelId)
    FOR sPreviousTaskId in:(objids) {
      CC "Core" GET_ATTR_VAL objid:(VAL sPreviousTaskId) attrname:("Task Id") as-string
      IF (ecode = 0) {
        SETL dummy:(aappend(previous_task_list, val))
      }
    }
    SETL task_map["previous_task_list"]:(previous_task_list)
    SETL tasks_map[task_id]:(task_map)
  }

  SETL max_end_time:(start_time)
  #CC "AdoScript" VIEWBOX  text:(resources_map)
  WHILE (1) {
    SETL current_tasks_list:(array(0))
    FOR sTaskId in:(sTaskIdList) {
      CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Task Id") as-string
      SETL task_id:(val)
      IF (task_id IN executed_tasks_list) {
        NEXT
      }
      SETL task_enabled:(1)
      FOR i from:0 to:(LEN tasks_map[task_id, "previous_task_list"] - 1) {
        IF (NOT (tasks_map[task_id, "previous_task_list", i] IN executed_tasks_list)) {
          SETL task_enabled:(0)
          BREAK
        }
      }
      IF (task_enabled = 0) {
        NEXT
      }
      SETL dummy:(aappend(current_tasks_list, task_id))
    }

    IF ((LEN current_tasks_list) = 0) {
      BREAK
    }
    #CC "AdoScript" VIEWBOX  text:(current_tasks_list)
    
    FOR i from:0 to:(LEN current_tasks_list - 1) {
      SETL nObjid:(VAL tasks_map[current_tasks_list[i], "adoxx_id"])
      SETL current_duration:(tasks_map[current_tasks_list[i], "duration"])
      IF (current_duration = "00:000:00:00:00") {
        #TO FIX: how to handle?
        #Current: Invalid case. Every task in the template need a duration. Problem: we need a separate template for almost each activity as every activity has different duration. 
        #Approach 1: add the duration only on some tasks like safety and quality control and split the rest between the other tasks. Problem: also safety and quality control tasks can be affected by the parent task duration (eg. longer sections require more time to check)
        #Approach 2: use percentage instead of duration (keeping the parent schedule limit). Eg. safety 1% -> task 97% -> quality 2% = total 100% . Problem: the task can be done in the 97% of the original plan?
        #Approach 3: use percentage instead of duration (exceeding the parent schedule limit). Eg. safety 1% -> task 100% -> quality 2% = total 103%. Problem: the start time of the next activity have to slide and the total project duration will increase
        CC "AdoScript" ERRORBOX ("No duration provided for the task \"" + tasks_map[current_tasks_list[i], "name"] + "\" in the model with id " + STR nModelId)
        EXIT
        #CC "Core" SET_ATTR_VAL objid:(nObjid) attrname:("Start Date") val:("") as-string
        #CC "Core" SET_ATTR_VAL objid:(nObjid) attrname:("End Date") val:("") as-string
      } ELSE {
        CC "Core" SET_ATTR_VAL objid:(nObjid) attrname:("Start Date") val:(start_time) as-string
        SETL new_end_time:(applyAdoxxTimeToIsoDateTimeString(start_time, current_duration))
        CC "Core" SET_ATTR_VAL objid:(nObjid) attrname:("End Date") val:(new_end_time) as-string

        IF (compareIsoDateTimeStrings(new_end_time, max_end_time) > 0) {
          SET max_end_time:(new_end_time)
        }
      }

      SETL dummy:(aappend(executed_tasks_list, current_tasks_list[i]))
    }

    SET start_time:(max_end_time)
  }

  IF (compareIsoDateTimeStrings(max_end_time, end_time) > 0) {
    CC "AdoScript" ERRORBOX ("The sub-process duration ("+max_end_time+") exceed the scheduled end time ("+end_time+") for the task \"" + parent_task_name + "\"")
    EXIT
  }

  CC "Modeling" SAVE modelid:(modelid)
}






PROCEDURE global COGITO_EXPORT_JSON_NEW nModelId:integer nExportBIM:integer json:reference {
  SETL json:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (json, "dummy"))
  SETL replacement_map:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (replacement_map, "dummy"))
  SETL processed_resources_list:(array(0))
  CC "Modeling" OPEN modelids:(nModelId)
  CC "Core" GET_ATTR_VAL objid:(nModelId) attrname:("Original JSON")
  SETL sOriginalJSON_path:(val)
  IF (sOriginalJSON_path = "") {
    SETL sOriginalJSON:("")
  } ELSE {
    CC "AdoScript" FREAD file: (sOriginalJSON_path)
    SETL sOriginalJSON:(text)
  }
  
  IF (nExportBIM = 1 AND sOriginalJSON != "undefined" AND sOriginalJSON != "") {
    SETL original_json_map:(fromJson(sOriginalJSON))
    SETL json["zones"]:(original_json_map["zones"])
    SETL json["elements"]:(original_json_map["elements"])
  }
  CC "Core" GET_ATTR_VAL objid:(nModelId) attrname:("Project Id")
  SETL json["project_id"]:(val)

  SETL resources:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (resources, "dummy"))
  SETL tasks:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (tasks, "dummy"))
  CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(nModelId) classname:"Task (BPMN)"
  SETL objids_task:(objids)
  CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(nModelId) classname:"Sub-Process (BPMN)"
  SETL objids_sub:(objids)
  SETL objids:(tokunion(objids_task, objids_sub))
  FOR sTaskId in:(objids) {
    SETL task:({"dummy":"dummy_is_a_map_not_an_array"})
    SETL dummy: (merase (task, "dummy"))

    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Task Id") as-string
    SETL task_id:(val)

    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Name") as-string
    SETL sTaskName:(val)
    SETL task_name:(val)
    IF (search(task_name, task_id+"-", 0) != -1) {
      SETL index:(search(task_name, task_id+"-", 0) + LEN task_id + 1)
      SETL task_name:(copy(task_name, index, LEN task_name - index))
    }

    SETL task["name"]:(task_name)



    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("COGITO Task Type") as-string
    SETL task["type"]:(val)

    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Add unassigned elements") as-string
    SETL task["handle_unassigned_elements"]:(val)

    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Use parent name") as-string
    SETL task["use_parent_name"]:(val)

    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Parent Task Id") as-string
    SETL task["parent_task"]:(val)

    SETL task["sub_task_list"]:(array(0))

    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Start Date") as-string
    SETL task_start_date:(val)
    SETL task["start_time"]:(val)
    
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("End Date") as-string
    SETL task_end_date:(val)
    SETL task["end_time"]:(val)

    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Duration") as-string
    SETL task["duration"]:(val)

    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Description") as-string
    SETL task["description"]:(val)

    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("work_quantity") as-string
    SETL task_work_quantity:(VAL val)
    SETL task["work_quantity"]:(VAL val)

    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("work_quantity_unit") as-string
    SETL task_work_quantity_unit:(val)
    SETL task["work_quantity_unit"]:(val)

    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("crew_productivity") as-string
    SETL task_crew_productivity:(VAL val)
    SETL task["crew_productivity"]:(VAL val)

    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("crew_number") as-string
    SETL task_crew_number:(VAL val)
    SETL task["crew_number"]:(VAL val)

    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("crew_productivity_penalty") as-string
    SETL task_crew_productivity_penalty:(VAL val)
    SETL task["crew_productivity_penalty"]:(VAL val)


    #previous_task_list
    SETL previous_task_list:(array(0))
    CC "AQL" EVAL_AQL_EXPRESSION expr:("({\""+sTaskName+"\":\"Task (BPMN)\"} <- \"Subsequent\") OR ({\""+sTaskName+"\":\"Sub-Process (BPMN)\"} <- \"Subsequent\")") modelid: (nModelId)
    FOR sPreviousTaskId in:(objids) {
      CC "Core" GET_ATTR_VAL objid:(VAL sPreviousTaskId) attrname:("Task Id") as-string
      IF (ecode = 0) {
        SETL dummy:(aappend(previous_task_list, val))
      }
    }
    SETL task["previous_task_list"]:(previous_task_list)

    #next_task_list
    SETL next_task_list:(array(0))
    CC "AQL" EVAL_AQL_EXPRESSION expr:("({\""+sTaskName+"\":\"Task (BPMN)\"} -> \"Subsequent\") OR ({\""+sTaskName+"\":\"Sub-Process (BPMN)\"} -> \"Subsequent\")") modelid: (nModelId)
    FOR sNextTaskId in:(objids) {
      CC "Core" GET_ATTR_VAL objid:(VAL sNextTaskId) attrname:("Task Id") as-string
      IF (ecode = 0) {
        SETL dummy:(aappend(next_task_list, val))
      }
    }
    SETL task["next_task_list"]:(next_task_list)

    #resource_list
    SETL resource_list:(array(0))
    CC "Core" GET_CLASS_ID objid:(VAL sTaskId)
    CC "Core" GET_ATTR_ID classid:(classid) attrname:("Resources") #attrid
    CC "Core" GET_REC_ATTR_ROW_COUNT objid:(VAL sTaskId) attrid:(attrid) #count
    FOR i from:1 to:(count) {
      SETL resource:({"dummy":"dummy_is_a_map_not_an_array"})
      SETL dummy: (merase (resource, "dummy"))
      CC "Core" GET_REC_ATTR_ROW_ID objid:(VAL sTaskId) attrid:(attrid) index:(i) #rowid
      CC "Core" GET_ATTR_VAL objid:(rowid) attrname:("Quantity") as-string #val
      SETL resource["quantity_needed"]:(VAL val)

      GET_INTERREF_OBJECT_ID nObjId:(rowid) sAttributeName:("Resource") sRefModelId:sRefModelId sRefObjId:sRefObjId
      CC "Core" GET_OBJ_NAME objid:(VAL sRefObjId)
      SETL resource_name:(objname)
      CC "Core" GET_ATTR_VAL objid:(VAL sRefObjId) attrname:("ID") as-string
      SETL resource_id:(val)
      CC "Core" GET_ATTR_VAL objid:(VAL sRefObjId) attrname:("Type") as-string
      SETL resource_type:(val)
      CC "Core" GET_ATTR_VAL objid:(VAL sRefObjId) attrname:("Quantity") as-string
      SETL resource_quantity:(VAL val)
      CC "Core" GET_ATTR_VAL objid:(VAL sRefObjId) attrname:("Cost_per_Hour") as-string
      SETL resource_cost:(VAL val)
      IF (NOT (resource_id IN processed_resources_list)) { #TODO remove processed_resources_list and use type(resources[resource_id]) = "undefined"
        SETL resources[resource_id]:({"name": resource_name, "type": resource_type, "quantity": resource_quantity, "cost_per_hour": resource_cost})
        SETL dummy:(aappend(processed_resources_list, resource_id))
      }
      SETL resource["resource_id"]:(resource_id)

      SETL dummy:(aappend(resource_list, resource))
    }
    SETL task["resource_list"]:(resource_list)


    SETL element_list:(array(0))
    SETL elements_list:(array(0))
    #CC "Core" GET_CLASS_ID classname:"Task (BPMN)"
    CC "Core" GET_CLASS_ID objid:(VAL sTaskId)
    CC "Core" GET_ATTR_ID classid:(classid) attrname:("Elements") #attrid
    CC "Core" GET_REC_ATTR_ROW_COUNT objid:(VAL sTaskId) attrid:(attrid) #count
    FOR i from:1 to:(count) {
      CC "Core" GET_REC_ATTR_ROW_ID objid:(VAL sTaskId) attrid:(attrid) index:(i) #rowid
      CC "Core" GET_ATTR_VAL objid:(rowid) attrname:("ID") as-string #val
      SETL element_json_id:(val)
      CC "Core" GET_ATTR_VAL objid:(rowid) attrname:("Action") as-string #val
      SETL element_json_action:(val)
      SETL dummy:(aappend(element_list, element_json_id))
      SETL dummy:(aappend(elements_list, {"element_id": element_json_id, "action": element_json_action}))
    }
    SETL task["element_list"]:(element_list)
    SETL task["elements_list"]:(elements_list)

    #subprocess handler
    GET_INTERREF_OBJECT_ID nObjId:(VAL sTaskId) sAttributeName:("Referenced subprocess") sRefModelId:sRefSubModelId sRefObjId:sNOTUSED
    IF (sRefSubModelId != "" AND sRefSubModelId != "0") {
      #CC "AdoScript" VIEWBOX  text:("sRefSubModelId: " + sRefSubModelId) #debug
      SETL empty_previous_map_array:(array(0))
      SETL empty_next_map_array:(array(0))
      
      #UPDATE_START_END_TIMES nModelId:(VAL sRefSubModelId) start_time:(task_start_date) end_time:(task_end_date) parent_task_name:(task_name)
      COGITO_EXPORT_JSON_NEW nModelId:(VAL sRefSubModelId) nExportBIM:(1) json:sub_json_map #if exportbim = 0 we need to export use_parent_name
      #CC "AdoScript" EDITBOX text:(sSubJSON)
      
      SETL sub_tasks:(sub_json_map["tasks"])

      FOR sub_tasks_id_list_i from:(0) to:(LEN sub_tasks - 1) {

        SETL sub_tasks_id:(sub_tasks.key(sub_tasks_id_list_i))
        SETL sub_task:(sub_tasks[sub_tasks_id])

        SETL sub_tasks_id_final:(task_id+sub_tasks_id)
        SETL sub_task_final:({"dummy":"dummy_is_a_map_not_an_array"}) #remove sub_task_final and use directly sub_task
        SETL dummy: (merase (sub_task_final, "dummy"))

        SETL sub_task_final["name"]:(sub_task["name"])
        IF (sub_task["use_parent_name"] = "Yes") {
          SETL sub_task_final["name"]:(task_name)
        }
        SETL sub_task_final["type"]:(sub_task["type"])
        SETL sub_task_final["parent_task"]:(sub_task["parent_task"])
        SETL sub_task_final["sub_task_list"]:(sub_task["sub_task_list"])
        SETL sub_task_final["start_time"]:(cond(sub_task["start_time"] != "", sub_task["start_time"], task_start_date))
        SETL sub_task_final["end_time"]:(cond(sub_task["end_time"] != "", sub_task["end_time"], task_end_date))
        SETL sub_task_final["description"]:(sub_task["description"])
        SETL sub_task_final["crew_productivity"]:(sub_task["crew_productivity"])
        SETL sub_task_final["crew_productivity_penalty"]:(sub_task["crew_productivity_penalty"])
        SETL sub_task_final["crew_number"]:(sub_task["crew_number"])
        #from parent
        SETL sub_task_final["work_quantity"]:(task_work_quantity)
        SETL sub_task_final["work_quantity_unit"]:(task_work_quantity_unit)
        

        SETL sub_task_previous_task_list:(sub_task["previous_task_list"])
        IF (LEN sub_task_previous_task_list = 0) {
          SETL dummy:(aappend(empty_previous_map_array, sub_tasks_id_final))
          SETL sub_task_previous_task_list:(previous_task_list)
        } ELSE {
          SETL sub_task_previous_task_list_final:(array(0))
          FOR sub_task_previous_task_list_i from:(0) to:(LEN sub_task_previous_task_list - 1) {
            SETL sub_task_previous_task_id:(sub_task_previous_task_list[sub_task_previous_task_list_i])
            SETL dummy:(aappend(sub_task_previous_task_list_final, task_id+sub_task_previous_task_id))
          }
          SETL sub_task_previous_task_list:(sub_task_previous_task_list_final)
        }
        SETL sub_task_final["previous_task_list"]:(sub_task_previous_task_list)


        SETL sub_task_next_task_list:(sub_task["next_task_list"])
        IF (LEN sub_task_next_task_list = 0) {
          SETL dummy:(aappend(empty_next_map_array, sub_tasks_id_final))
          SETL sub_task_next_task_list:(next_task_list)
        } ELSE {
          SETL sub_task_next_task_list_final:(array(0))
          FOR sub_task_next_task_list_i from:(0) to:(LEN sub_task_next_task_list - 1) {
            SETL sub_task_next_task_id:(sub_task_next_task_list[sub_task_next_task_list_i])
            SETL dummy:(aappend(sub_task_next_task_list_final, task_id+sub_task_next_task_id))
          }
          SETL sub_task_next_task_list:(sub_task_next_task_list_final)
        }
        SETL sub_task_final["next_task_list"]:(sub_task_next_task_list)


        SETL sub_task_final["resource_list"]:(sub_task["resource_list"])

        SETL sub_task_final["element_list"]:(element_list)
        SETL sub_task_final["elements_list"]:(elements_list)

        IF (LEN sub_task["element_list"] != 0) {
          SETL sub_task_final["element_list"]:(sub_task["element_list"])
          SETL sub_task_final["elements_list"]:(sub_task["elements_list"])
        }

        SETL tasks[sub_tasks_id_final]:(sub_task_final)
      }

      SETL sub_resources:(sub_json_map["resources"])
      FOR sub_resources_id_list_i from:(0) to:(LEN sub_resources - 1) {
        SETL sub_resources_id:(sub_resources.key(sub_resources_id_list_i))
        IF (NOT (sub_resources_id IN processed_resources_list)) {
          SETL sub_resource:(sub_resources[sub_resources_id])
          SETL resources[sub_resources_id]:(sub_resource)
          SETL dummy:(aappend(processed_resources_list, sub_resources_id))
        }
        
      }

      SETL replacement_map[task_id]:({"empty_previous_map_array": empty_previous_map_array, "empty_next_map_array":empty_next_map_array})
    } ELSE {
      SETL tasks[task_id]:(task)
    }

  }

  #CC "AdoScript" VIEWBOX text:(tasks) #debug
  #loop all the tasks, 
  #- for each task loop all the previous. if the previous id is in the replacement list replace the previous id with all the empty_next_map_array
  #- for each task loop all the nexts. if the next id is in the replacement list replace the previous id with all the empty_previous_map_array
  #REMINDER: the sub task id should not be the same of the original task id or the previous and next relations of the subtask will be replaced as well
  SETL tasks_final:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (tasks_final, "dummy"))

  FOR tasks_id_list_i from:(0) to:(LEN tasks - 1) {
    SETL task_final:({"dummy":"dummy_is_a_map_not_an_array"})
    SETL dummy: (merase (task_final, "dummy"))
    SETL pp_task_id:(tasks.key(tasks_id_list_i))
    SETL task:(tasks[pp_task_id])
    IF (type(task) != "map") {
      NEXT
    }
    SETL task_final["name"]:(task["name"])
    SETL task_final["type"]:(task["type"])
    SETL task_final["parent_task"]:(task["parent_task"])
    SETL task_final["sub_task_list"]:(task["sub_task_list"])
    SETL task_final["start_time"]:(task["start_time"])
    SETL task_final["end_time"]:(task["end_time"])
    SETL task_final["duration"]:(task["duration"])
    SETL task_final["description"]:(task["description"])
    SETL task_final["work_quantity"]:(task["work_quantity"])
    SETL task_final["work_quantity_unit"]:(task["work_quantity_unit"])
    SETL task_final["crew_number"]:(task["crew_number"])
    SETL task_final["crew_productivity"]:(task["crew_productivity"])
    SETL task_final["crew_productivity_penalty"]:(task["crew_productivity_penalty"])
    SETL task_final["resource_list"]:(task["resource_list"])
    SETL task_final["element_list"]:(task["element_list"])
    IF (nExportBIM = 1) {
      SETL task_final["elements_list"]:(task["elements_list"])
      SETL task_final["handle_unassigned_elements"]:(task["handle_unassigned_elements"])
      SETL task_final["use_parent_name"]:(task["use_parent_name"])
    }


    SETL pp_previous_task_list:(task["previous_task_list"])
    SETL pp_previous_task_list_final:(array(0))
    FOR pp_previous_task_list_i from:(0) to:(LEN pp_previous_task_list - 1) {
      SETL pp_previous_task_id:(pp_previous_task_list[pp_previous_task_list_i])
      IF (type(replacement_map[pp_previous_task_id]) != "undefined") {
        FOR i from:(0) to:(LEN replacement_map[pp_previous_task_id, "empty_next_map_array"] - 1) {
          SETL dummy:(aappend(pp_previous_task_list_final, replacement_map[pp_previous_task_id, "empty_next_map_array", i]))
        }
      } ELSE {
        SETL dummy:(aappend(pp_previous_task_list_final, pp_previous_task_id))
      }
    }
    SETL task_final["previous_task_list"]:(pp_previous_task_list_final)


    SETL pp_next_task_list:(task["next_task_list"])
    SETL pp_next_task_list_final:(array(0))
    FOR pp_next_task_list_i from:(0) to:(LEN pp_next_task_list - 1) {
      SETL pp_next_task_id:(pp_next_task_list[pp_next_task_list_i])
      IF (type(replacement_map[pp_next_task_id]) != "undefined") {
        FOR i from:(0) to:(LEN replacement_map[pp_next_task_id, "empty_previous_map_array"] - 1) {
          SETL dummy:(aappend(pp_next_task_list_final, replacement_map[pp_next_task_id, "empty_previous_map_array", i]))
        }
      } ELSE {
        SETL dummy:(aappend(pp_next_task_list_final, pp_next_task_id))
      }
    }
    SETL task_final["next_task_list"]:(pp_next_task_list_final)


    SETL tasks_final[pp_task_id]:(task_final)
  }

  SETL json["tasks"]:(tasks_final)
  SETL json["resources"]:(resources)
  #CC "AdoScript" VIEWBOX  text:(resources) # debug
}




PROCEDURE global COGITO_IMPORT_HS_NEW sJSON: string nTaskId: integer {
  SETL json_map:(fromJson(sJSON))
  SETL health_and_safety:(json_map["health_and_safety"])
  FOR health_and_safety_id_list_i from:(0) to:(LEN health_and_safety - 1) {
    SETL health_and_safety_id:(health_and_safety.key(health_and_safety_id_list_i))
    SETL health_and_safety_item:(health_and_safety[health_and_safety_id])

    SETL hs_description:(health_and_safety_item["description"])
    SETL hs_severity_level:(health_and_safety_item["severity_level"])
    SETL hs_mitigation:(health_and_safety_item["mitigation"])
    SETL hs_safety_zone:(health_and_safety_item["safety_zone"])
    SETL hs_construction_zone:(health_and_safety_item["construction_zone"])
    SETL hs_mitigation_zone:(health_and_safety_item["mitigation_zone"])

    CC "Core" GET_CLASS_ID objid:(nTaskId)
    CC "Core" GET_ATTR_ID classid:(classid) attrname:"Health_and_Safety"
    CC "Core" ADD_REC_ROW objid:(nTaskId) attrid:(attrid)
    CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Description") val:(hs_description) as-string
    CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Severity_Level") val:(hs_severity_level) as-string
    CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Mitigation") val:(hs_mitigation) as-string
    CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Safety_Zone") val:(hs_safety_zone) as-string
    CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Construction_Zone") val:(hs_construction_zone) as-string
    CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Mitigation_Zone") val:(hs_mitigation_zone) as-string
  }

  SETL resources_location:(json_map["resources_location"])
  FOR resources_location_id_list_i from:(0) to:(LEN resources_location - 1) {
    SETL resources_location_id:(resources_location.key(resources_location_id_list_i))
    SETL resources_location_item:(resources_location[resources_location_id])

    SETL rl_name:(resources_location_item["name"])
    SETL rl_group_name:(resources_location_item["group_name"])
    SETL location_data_list:(resources_location_item["location_data"])
    FOR location_data_list_i from:(0) to:(LEN location_data_list - 1) {
      SETL location_data:(location_data_list[location_data_list_i])
      SETL rl_timestamp:(location_data["timestamp"])
      SETL rl_zone:(location_data["zone"])

      CC "Core" GET_CLASS_ID objid:(nTaskId)
      CC "Core" GET_ATTR_ID classid:(classid) attrname:"Location_Tracking"
      CC "Core" ADD_REC_ROW objid:(nTaskId) attrid:(attrid)
      CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Resource_Name") val:(rl_name) as-string
      CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Group") val:(rl_group_name) as-string
      CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Time") val:(rl_timestamp) as-string
      CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Zone") val:(rl_zone) as-string
    }
  }
}

PROCEDURE global COGITO_IMPORT_HS sJSON: string nTaskId: integer {
  JSON_GET sJSON:(sJSON) sKey:("health_and_safety") sContent: health_and_safety sContentType: sContentType
  JSON_GET_KEYS sJSON:(health_and_safety) sContent: health_and_safety_id_list sContentType: sContentType
  ARRAY_GET_LENGTH sArray:(health_and_safety_id_list) sContent: health_and_safety_id_list_length sContentType: sContentType
  FOR health_and_safety_id_list_i from:(0) to:(VAL health_and_safety_id_list_length - 1) {
    ARRAY_GET sArray:(health_and_safety_id_list) nArrayIndex:(health_and_safety_id_list_i) sContent: health_and_safety_id sContentType: sContentType
    JSON_GET sJSON:(health_and_safety) sKey:(health_and_safety_id) sContent: health_and_safety_item sContentType: sContentType

    JSON_GET sJSON:(health_and_safety_item) sKey:("description") sContent: hs_description sContentType: sContentType
    JSON_GET sJSON:(health_and_safety_item) sKey:("severity_level") sContent: hs_severity_level sContentType: sContentType
    JSON_GET sJSON:(health_and_safety_item) sKey:("mitigation") sContent: hs_mitigation sContentType: sContentType
    JSON_GET sJSON:(health_and_safety_item) sKey:("safety_zone") sContent: hs_safety_zone sContentType: sContentType
    JSON_GET sJSON:(health_and_safety_item) sKey:("construction_zone") sContent: hs_construction_zone sContentType: sContentType
    JSON_GET sJSON:(health_and_safety_item) sKey:("mitigation_zone") sContent: hs_mitigation_zone sContentType: sContentType
    
    #CC "Core" GET_CLASS_ID classname:"Task (BPMN)"
    CC "Core" GET_CLASS_ID objid:(nTaskId)
    CC "Core" GET_ATTR_ID classid:(classid) attrname:"Health_and_Safety"
    CC "Core" ADD_REC_ROW objid:(nTaskId) attrid:(attrid)
    CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Description") val:(hs_description) as-string
    CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Severity_Level") val:(hs_severity_level) as-string
    CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Mitigation") val:(hs_mitigation) as-string
    CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Safety_Zone") val:(hs_safety_zone) as-string
    CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Construction_Zone") val:(hs_construction_zone) as-string
    CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Mitigation_Zone") val:(hs_mitigation_zone) as-string
  }


  JSON_GET sJSON:(sJSON) sKey:("resources_location") sContent: resources_location sContentType: sContentType
  JSON_GET_KEYS sJSON:(resources_location) sContent: resources_location_id_list sContentType: sContentType
  ARRAY_GET_LENGTH sArray:(resources_location_id_list) sContent: resources_location_id_list_length sContentType: sContentType
  FOR resources_location_id_list_i from:(0) to:(VAL resources_location_id_list_length - 1) {
    ARRAY_GET sArray:(resources_location_id_list) nArrayIndex:(resources_location_id_list_i) sContent: resources_location_id sContentType: sContentType
    JSON_GET sJSON:(resources_location) sKey:(resources_location_id) sContent: resources_location_item sContentType: sContentType

    JSON_GET sJSON:(resources_location_item) sKey:("name") sContent: rl_name sContentType: sContentType
    JSON_GET sJSON:(resources_location_item) sKey:("group_name") sContent: rl_group_name sContentType: sContentType
    
    JSON_GET sJSON:(resources_location_item) sKey:("location_data") sContent: location_data_list sContentType: sContentType
    ARRAY_GET_LENGTH sArray:(location_data_list) sContent: location_data_list_length sContentType: sContentType
    FOR location_data_list_i from:(0) to:(VAL location_data_list_length - 1) {
      ARRAY_GET sArray:(location_data_list) nArrayIndex:(location_data_list_i) sContent: location_data sContentType: sContentType
      JSON_GET sJSON:(location_data) sKey:("timestamp") sContent: rl_timestamp sContentType: sContentType
      JSON_GET sJSON:(location_data) sKey:("zone") sContent: rl_zone sContentType: sContentType

      #CC "Core" GET_CLASS_ID classname:"Task (BPMN)"
      CC "Core" GET_CLASS_ID objid:(nTaskId)
      CC "Core" GET_ATTR_ID classid:(classid) attrname:"Location_Tracking"
      CC "Core" ADD_REC_ROW objid:(nTaskId) attrid:(attrid)
      CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Resource_Name") val:(rl_name) as-string
      CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Group") val:(rl_group_name) as-string
      CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Time") val:(rl_timestamp) as-string
      CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Zone") val:(rl_zone) as-string
    }
  }
}


PROCEDURE global COGITO_RUN_PROCESS {
  #CC "CoreUI" MODEL_SELECT_BOX oktext:"Run" boxtext:"Please select your process models:" title:"Process Execution"
  CC "ImportExport" SHOW_EXPORT_DLG multi-select:0 mode: "csv" title: "Select the Models to Execute" filedescription: "csv format" fileextension: "*.csv"
  IF (endbutton != "ok") {
    EXIT
  }
  SETL sExportPath:(filename)
  SETL nModelId:(VAL modelids)

  SETL tasks_map:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (tasks_map, "dummy"))
  SETL running_tasks_list:(array(0))
  SETL executed_tasks_list:(array(0))
  SETL processed_resources_list:(array(0))
  SETL resources_map:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (resources_map, "dummy"))

  SETL csv_content:("")
  #CC "Modeling" OPEN modelids:(nModelId)
  CC "Core" LOAD_MODEL modelid:(nModelId)

  CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(nModelId) classname:"Sub-Process (BPMN)"
  SETL sTaskIdList:(objids)
  FOR sTaskId in:(objids) {
    SETL task_map:({"dummy":"dummy_is_a_map_not_an_array"})
    SETL dummy: (merase (task_map, "dummy"))
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Task Id") as-string
    SETL task_id:(val)
    SETL task_map["id"]:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Name") as-string
    SETL sTaskName:(val)
    SETL task_map["name"]:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Start Date") as-string
    SETL task_map["start_time"]:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("End Date") as-string
    SETL task_map["end_time"]:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Description") as-string
    SETL task_map["description"]:(val)

    SETL resources_list:(array(0))
    CC "Core" GET_CLASS_ID objid:(VAL sTaskId)
    CC "Core" GET_ATTR_ID classid:(classid) attrname:("Resources") #attrid
    CC "Core" GET_REC_ATTR_ROW_COUNT objid:(VAL sTaskId) attrid:(attrid) #count
    FOR i from:1 to:(count) {
      CC "Core" GET_REC_ATTR_ROW_ID objid:(VAL sTaskId) attrid:(attrid) index:(i) #rowid
      CC "Core" GET_ATTR_VAL objid:(rowid) attrname:("Quantity") as-string #val
      SETL resource_quantity_needed:(val)

      GET_INTERREF_OBJECT_ID nObjId:(rowid) sAttributeName:("Resource") sRefModelId:sRefModelId sRefObjId:sRefObjId
      CC "Core" GET_ATTR_VAL objid:(VAL sRefObjId) attrname:("ID") as-string
      SETL resource_id:(val)
      IF (NOT (resource_id IN processed_resources_list)) {
        SETL resource_map:({"dummy":"dummy_is_a_map_not_an_array"})
        SETL dummy: (merase (resource_map, "dummy"))
        SETL resource_map["id"]:(resource_id)
        CC "Core" GET_OBJ_NAME objid:(VAL sRefObjId)
        SETL resource_map["name"]:(objname)
        CC "Core" GET_ATTR_VAL objid:(VAL sRefObjId) attrname:("Type") as-string
        SETL resource_map["type"]:(val)
        CC "Core" GET_ATTR_VAL objid:(VAL sRefObjId) attrname:("Quantity") as-string
        SETL resource_map["quantity"]:(val)
        CC "Core" GET_ATTR_VAL objid:(VAL sRefObjId) attrname:("Cost_per_Hour") as-string
        SETL resource_map["cost_per_hour"]:(val)
        SETL resources_map[resource_id]:(resource_map)
        SETL dummy:(aappend(processed_resources_list, resource_id))
      }
      SETL dummy:(aappend(resources_list, {"id": resource_id, "quantity_needed":resource_quantity_needed}))
    }
    SETL task_map["resources_list"]:(resources_list)

    SETL previous_task_list:(array(0))
    CC "AQL" EVAL_AQL_EXPRESSION expr:("({\""+sTaskName+"\":\"Task (BPMN)\"} <- \"Subsequent\") OR ({\""+sTaskName+"\":\"Sub-Process (BPMN)\"} <- \"Subsequent\")") modelid: (nModelId)
    FOR sPreviousTaskId in:(objids) {
      CC "Core" GET_ATTR_VAL objid:(VAL sPreviousTaskId) attrname:("Task Id") as-string
      IF (ecode = 0) {
        SETL dummy:(aappend(previous_task_list, val))
      }
    }
    SETL task_map["previous_task_list"]:(previous_task_list)
    SETL tasks_map[task_id]:(task_map)
  }

  #CC "AdoScript" VIEWBOX  text:(resources_map)

  WHILE (1) {
    SETL current_tasks_list:(array(0))
    FOR sTaskId in:(sTaskIdList) {
      CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Task Id") as-string
      SETL task_id:(val)
      IF (task_id IN executed_tasks_list) {
        NEXT
      }
      SETL task_enabled:(1)
      FOR i from:0 to:(LEN tasks_map[task_id, "previous_task_list"] - 1) {
        IF (NOT (tasks_map[task_id, "previous_task_list", i] IN executed_tasks_list)) {
          SETL task_enabled:(0)
          BREAK
        }
      }
      IF (task_enabled = 0) {
        NEXT
      }
      SETL dummy:(aappend(current_tasks_list, task_id))
    }

    IF ((LEN current_tasks_list) = 0) {
      BREAK
    }

    # propose to the user the task to execute, then show the description and needed resources, and finally ask for the duration. Add to the executed_list only the executed task
    #CC "AdoScript" VIEWBOX  text:(current_tasks_list)

    SETL tasks_name_list:("")
    SETL tasks_default_selection:("")
    FOR i from:0 to:(LEN current_tasks_list - 1) {
      SETL tasks_name_list:(tasks_name_list + ";" + tasks_map[current_tasks_list[i], "name"])
    }
    IF (LEN tasks_name_list != 0) {
      SETL tasks_name_list:(copy(tasks_name_list, 1, LEN tasks_name_list))
      SETL tasks_default_selection:(token(tasks_name_list, 0, ";"))
    }

    CC "AdoScript" LISTBOX entries:(tasks_name_list) selection:(tasks_default_selection) toksep:";" title:"Tasks to Perform" boxtext:"Choose the task to start"
    IF (endbutton != "ok") {
      BREAK
    }
    SETL started_task_id:("")
    FOR i from:0 to:(LEN current_tasks_list - 1) {
      IF (selection = tasks_map[current_tasks_list[i], "name"]) {
        SETL started_task_id:(current_tasks_list[i])
      }
    }
    IF (started_task_id = "") {
      CC "AdoScript" ERRORBOX ("IMPOSSIBLE TO FIND THE SELECTED TASK: " + selection)
      BREAK
    }

    SETL task_infos:("Task ID: " +  tasks_map[started_task_id, "id"] + "\n" + "Task Name: " +  tasks_map[started_task_id, "name"] + "\n" + "Description: " +  tasks_map[started_task_id, "description"] + "\n" + "Planned Start Date: " +  tasks_map[started_task_id, "start_time"] + "\n" + "Planned End Date: " +  tasks_map[started_task_id, "end_time"] + "\n" + "Resources: \n")
    #CC "AdoScript" VIEWBOX  text:(resources_map)
    #CC "AdoScript" VIEWBOX  text:(tasks_map[started_task_id, "resources_list"])
    FOR i from:0 to:(LEN tasks_map[started_task_id, "resources_list"] - 1) {
      SETL used_resource_id:(tasks_map[started_task_id, "resources_list", i, "id"])
      SETL used_resource_quantity_needed:(tasks_map[started_task_id, "resources_list", i, "quantity_needed"])
      SETL task_infos:(task_infos + "- " + resources_map[used_resource_id, "name"] + " (" + resources_map[used_resource_id, "type"] + ") : " + used_resource_quantity_needed + "   Max: " + resources_map[used_resource_id, "quantity"] + ", Cost: " + resources_map[used_resource_id, "cost_per_hour"] + "\n")
    }

    CC "AdoScript" VIEWBOX text:(task_infos) title:("Execution Details for task " + tasks_map[started_task_id, "name"])

    CC "AdoScript" EDITFIELD title:("Duration for " + tasks_map[started_task_id, "name"]) caption:"Task Duration (Hours):" text:"1"
    IF (ecode != 0) {
      BREAK
    }
    SETL csv_content:(csv_content + "\n" + mstr(tasks_map[started_task_id, "id"]) + "," + mstr(tasks_map[started_task_id, "name"]) + "," + mstr(text))

    SETL dummy:(aappend(executed_tasks_list, started_task_id))
    #FOR i from:0 to:(LEN current_tasks_list - 1) {
    #  SETL dummy:(aappend(executed_tasks_list, current_tasks_list[i]))
    #}
  }
  
  CC "AdoScript" FWRITE file: (sExportPath) text: (csv_content) append: 0 binary: 0 base64: 0
  CC "AdoScript" INFOBOX "Run Terminated"
}


PROCEDURE global ORDER_MODEL modelid:integer {

  SETL nModelId:(modelid)

  SETL tasks_map:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (tasks_map, "dummy"))
  SETL running_tasks_list:(array(0))
  SETL executed_tasks_list:(array(0))

  #CC "Modeling" OPEN modelids:(nModelId)
  CC "Core" LOAD_MODEL modelid:(nModelId)

  CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(nModelId) classname:"Sub-Process (BPMN)"
  SETL sTaskIdList:(objids)
  FOR sTaskId in:(objids) {
    SETL task_map:({"adoxx_id": sTaskId})
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Task Id") as-string
    SETL task_id:(val)
    SETL task_map["id"]:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Name") as-string
    SETL sTaskName:(val)
    SETL task_map["name"]:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Start Date") as-string
    SETL task_map["start_time"]:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("End Date") as-string
    SETL task_map["end_time"]:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Description") as-string
    SETL task_map["description"]:(val)

    SETL previous_task_list:(array(0))
    CC "AQL" EVAL_AQL_EXPRESSION expr:("({\""+sTaskName+"\":\"Task (BPMN)\"} <- \"Subsequent\") OR ({\""+sTaskName+"\":\"Sub-Process (BPMN)\"} <- \"Subsequent\")") modelid: (nModelId)
    FOR sPreviousTaskId in:(objids) {
      CC "Core" GET_ATTR_VAL objid:(VAL sPreviousTaskId) attrname:("Task Id") as-string
      IF (ecode = 0) {
        SETL dummy:(aappend(previous_task_list, val))
      }
    }
    SETL task_map["previous_task_list"]:(previous_task_list)
    SETL tasks_map[task_id]:(task_map)
  }

  #CC "AdoScript" VIEWBOX  text:(resources_map)
  SETL order_index:(1)
  WHILE (1) {
    SETL current_tasks_list:(array(0))
    FOR sTaskId in:(sTaskIdList) {
      CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Task Id") as-string
      SETL task_id:(val)
      IF (task_id IN executed_tasks_list) {
        NEXT
      }
      SETL task_enabled:(1)
      FOR i from:0 to:(LEN tasks_map[task_id, "previous_task_list"] - 1) {
        IF (NOT (tasks_map[task_id, "previous_task_list", i] IN executed_tasks_list)) {
          SETL task_enabled:(0)
          BREAK
        }
      }
      IF (task_enabled = 0) {
        NEXT
      }
      SETL dummy:(aappend(current_tasks_list, task_id))
    }

    IF ((LEN current_tasks_list) = 0) {
      BREAK
    }

    # set task position and increase new line
    #CC "AdoScript" VIEWBOX  text:(current_tasks_list)


    FOR i from:0 to:(LEN current_tasks_list - 1) {
      CC "Modeling" SET_OBJ_POS objid:(VAL tasks_map[current_tasks_list[i], "adoxx_id"]) x:(2cm + order_index*4cm) y:(i*4cm + 2cm)
      SETL dummy:(aappend(executed_tasks_list, current_tasks_list[i]))
    }
    SETL order_index:(order_index+1)
  }
  CC "Modeling" SAVE modelid:(modelid)
}


PROCEDURE global CURL method:string url: string params: string result: reference {
    CC "AdoScript" GET_TEMP_FILENAME
    SETL sTempFilename: (filename)
    SETL sTempFolder: (copy ( sTempFilename , 0 , bsearch ( sTempFilename , "\\" , (LEN sTempFilename)-1 )+1 ))
    SETL sRestClientName: ("curl.exe")
    SETL curlPath:(sTempFolder+sRestClientName)
    CC "AdoScript" FILE_EXISTS file:(curlPath)
    IF (exists = 0) {
      CC "AdoScript" FILE_COPY from: ("db:\\"+sRestClientName) to: (curlPath)
    }
    SETL sTempOutputFilePath:(filename+".CURL_OUTPUT")
    SETL sTempTraceFilePath:(filename+".CURL_TRACE")
    SYSTEM ( "cmd /c "+curlPath+" --insecure --location --request "+method+" --trace-ascii \""+sTempTraceFilePath+"\" \""+url+"\" "+params+" >"+sTempOutputFilePath)
    CC "AdoScript" FREAD file: (sTempOutputFilePath)
    SETL result:(text)
    IF (result != "") {
        CC "AdoScript" FILE_DELETE file: (sTempOutputFilePath)
        CC "AdoScript" FILE_DELETE file: (sTempTraceFilePath)
    } ELSE {
        CC "AdoScript" FREAD file: (sTempTraceFilePath)
        SETL result:(text)
    }
}

PROCEDURE global ASK_COGITO_CREDENTIALS username:reference password:reference {
  SETL username:("")
  SETL password:("")
  CC "AdoScript" GET_TEMP_FILENAME
  #NOTE: https://stackoverflow.com/questions/5596982/using-powershell-to-write-a-file-in-utf-8-without-the-bom
  SYSTEM ("powershell -Command \"$credentials = $host.ui.promptForCredential('COGITO Login', 'Login with your COGITO credentials', '', 'COGITO_ADOXX_CLIENT_TARGET', 1, 0) ; $null = New-Item -Force "+filename+" -Value ($credentials.GetNetworkCredential().Username + '\n' + $credentials.GetNetworkCredential().Password)\"") result:res
  IF (res = 0) {
    CC "AdoScript" FREAD file:(filename)
    SETL username:(token(text, 0, "\n"))
    SETL password:(token(text, 1, "\n"))
  }
  CC "AdoScript" FILE_DELETE file:(filename)
  #CC "AdoScript" VIEWBOX text:("username: " + username + "\npassword: " + password)
}
#ASK_COGITO_CREDENTIALS username:username password:password


PROCEDURE global DTP_LOGIN username:string password:string access_token:reference email:reference {
  SETL str_url:("https://auth.cogito-project.com/auth/realms/cogito/protocol/openid-connect/token")
  SETL client_id:("cogito-demo")
  SETL client_secret:("72008waBroLQwqrH13Z4UbmMOm9e5gpe")

  SETL access_token:("")
  SETL email:("")
  #CC "AdoScript" HTTP_REQUEST (str_url) verb:("GET")
  #IF (type(response) = "undefined") {
  #  CC "AdoScript" ERRORBOX ("NO RESPONSE")
  CURL method:("POST") url:(str_url) params:("--header \"Content-Type: application/x-www-form-urlencoded\" --data-urlencode \"password="+password+"\" --data-urlencode \"username="+username+"\" --data-urlencode \"client_id="+client_id+"\" --data-urlencode \"client_secret="+client_secret+"\" --data-urlencode \"grant_type=password\"") result:str_respbody
  #HTTP_SEND_REQUEST (str_url) str_method:("GET") map_reqheaders:({"API-Key": str_apikey}) str_reqbody:("") val_respcode:val_httpcode map_respheaders:map_respheaders str_respbody:str_respbody
  IF (search(str_respbody,"ERROR:",0) != -1) {
    CC "AdoScript" ERRORBOX (str_respbody)
  }  ELSE {
    #CC "AdoScript" VIEWBOX text:(str_respbody)
    SETL auth_json:(fromJson(str_respbody))
    IF (type(auth_json["error"]) != "undefined") {
      CC "AdoScript" ERRORBOX (auth_json["error_description"])
    } ELSE {
      SETL access_token:(auth_json["access_token"])
      SETL payloadB64:(token(access_token, 1, "."))
      WHILE (LEN payloadB64 MOD 4 != 0) {
        SETL payloadB64:(payloadB64 + "=")
      } 
      SETL payload:(base64decode(payloadB64))
      SETL payload_json:(fromJson(payload))
      SETL email:(payload_json["email"])
    }
  }
}
#DTP_LOGIN username:("damiano.falcioni@boc-group.com") password:("") access_token:access_token email:email


PROCEDURE global DTP_GET_PROJECTS name_array:reference id_array:reference {
  SETL str_url:("https://dtp.cogito-project.com/api/projects")
  SETL str_apikey:("b44909da-473d-48f8-a0d1-96b43a796f7e")
  SETL name_array:(array(0))
  SETL id_array:(array(0))

  #CC "AdoScript" HTTP_REQUEST (str_url) verb:("GET")
  #IF (type(response) = "undefined") {
  #  CC "AdoScript" ERRORBOX ("NO RESPONSE")
  CURL method:("GET") url:(str_url) params:("--header \"API-Key: "+str_apikey+"\"") result:str_respbody
  #HTTP_SEND_REQUEST (str_url) str_method:("GET") map_reqheaders:({"API-Key": str_apikey}) str_reqbody:("") val_respcode:val_httpcode map_respheaders:map_respheaders str_respbody:str_respbody
  IF (search(str_respbody,"ERROR:",0) != -1) {
    CC "AdoScript" ERRORBOX (str_respbody)
  }  ELSE {
    #CC "AdoScript" VIEWBOX text:(str_respbody)
    SETL projects_list:(fromJson(str_respbody))
    FOR i from:(0) to:(LEN projects_list - 1) {
      SETL project:(projects_list[i])
      SETL project_name:(project["name"])
      SETL project_id:(project["id"])
      SETL dummy:(aappend(name_array, project_name))
      SETL dummy:(aappend(id_array, project_id))
    }
  }
}

PROCEDURE global DTP_GET_PROJECT_USERS project_id:string users_array:reference email_array:reference {
  SETL str_url:("https://dtp.cogito-project.com/api/projects/" + project_id + "/users")
  SETL str_apikey:("b44909da-473d-48f8-a0d1-96b43a796f7e")
  SETL users_array:(array(0))
  SETL email_array:(array(0))
  #CC "AdoScript" HTTP_REQUEST (str_url) verb:("GET")
  #IF (type(response) = "undefined") {
  #  CC "AdoScript" ERRORBOX ("NO RESPONSE")
  CURL method:("GET") url:(str_url) params:("--header \"API-Key: "+str_apikey+"\"") result:str_respbody
  #HTTP_SEND_REQUEST (str_url) str_method:("GET") map_reqheaders:({"API-Key": str_apikey}) str_reqbody:("") val_respcode:val_httpcode map_respheaders:map_respheaders str_respbody:str_respbody
  IF (search(str_respbody,"ERROR:",0) != -1) {
    CC "AdoScript" ERRORBOX (str_respbody)
  }  ELSE {
    #CC "AdoScript" VIEWBOX text:(str_respbody)
    SETL users_array:(fromJson(str_respbody))
    FOR i from:(0) to:(LEN users_array - 1) {
      SETL dummy:(aappend(email_array, users_array[i, "email"]))
    }
  }

}


PROCEDURE global DTP_GET_FILTERED_PROJECTS email:string name_array:reference id_array:reference {
  DTP_GET_PROJECTS name_array:all_name_array id_array:all_id_array
  SETL name_array:(array(0))
  SETL id_array:(array(0))
  FOR i from:(0) to:(LEN all_id_array - 1) {
    DTP_GET_PROJECT_USERS project_id:(all_id_array[i]) users_array:users_array email_array:email_array
    IF (email IN email_array) {
      SETL dummy:(aappend(name_array, all_name_array[i]))
      SETL dummy:(aappend(id_array, all_id_array[i]))
    }
  }
}

PROCEDURE global SELECT_COGITO_PROJECT name_array:array id_array:array project_id:reference {
  SETL project_id:("")
  SETL nameList:("")
  FOR i from:(0) to:(LEN name_array - 1) {
    SETL nameList:(nameList+";"+STR (i+1) + ") " + name_array[i])
  }
  IF (LEN nameList != 0) {
    SETL nameList:(copy(nameList, 1, LEN nameList))
  }
  CC "AdoScript" LISTBOX entries:(nameList) toksep:";" title:"COGITO Projects" boxtext:"Choose the project to use:"
  IF (endbutton = "ok") {
    SETL selectedProjectIndex:(VAL copy(selection, 0, search(selection, ")", 0)))
    SETL project_id:(id_array[selectedProjectIndex-1])
  }
}

PROCEDURE global DTP_GET_PROJECT_LAST_COLLECTION project_id:string collection_id:reference {
  SETL str_endpoint_UC11R06:("18f2786f-313b-470f-8812-12bde350f4c8")
  SETL str_url:("https://dtp.cogito-project.com/api/endpoints/"+str_endpoint_UC11R06+"/projects/"+project_id+"/collections")
  SETL str_apikey:("b44909da-473d-48f8-a0d1-96b43a796f7e")
  SETL collection_id:("")

  CURL method:("GET") url:(str_url) params:("--header \"API-Key: "+str_apikey+"\"") result:str_respbody
  IF (search(str_respbody,"ERROR:",0) != -1) {
    CC "AdoScript" ERRORBOX (str_respbody)
  }  ELSE {
    SETL collections_list:(str_respbody)
    ARRAY_GET_LENGTH sArray:(collections_list) sContent: collections_list_length sContentType: sContentType
    FOR collections_list_i from:(0) to:(VAL collections_list_length - 1) {
      ARRAY_GET sArray:(collections_list) nArrayIndex:(collections_list_i) sContent: collection sContentType: sContentType
      JSON_GET sJSON:(collection) sKey:("status") sContent: collection_status sContentType: sContentType
      IF (collection_status = "completed") {
        JSON_GET sJSON:(collection) sKey:("id") sContent: collection_id sContentType: sContentType
        BREAK
      }
    }
  }
}

PROCEDURE global DTP_CREATE_DOWNLOAD_COLLECTION project_id:string collection_id:reference {
  SETL str_endpoint_UC11R06:("18f2786f-313b-470f-8812-12bde350f4c8")
  SETL str_url:("https://dtp.cogito-project.com/api/collections/create")
  SETL str_apikey:("b44909da-473d-48f8-a0d1-96b43a796f7e")
  SETL collection_id:("")

  CURL method:("POST") url:(str_url) params:("--header \"API-Key: "+str_apikey+"\" --form \"endpointId="+str_endpoint_UC11R06+"\" --form \"projectId="+project_id+"\"") result:str_respbody
  IF (search(str_respbody,"ERROR:",0) != -1) {
    CC "AdoScript" ERRORBOX (str_respbody)
  }  ELSE {
    SETL collection:(fromJson(str_respbody))
    SETL collection_id:(collection["id"])
  }
}

PROCEDURE global DTP_CREATE_UPLOAD_COLLECTION project_id:string collection_id:reference {
  SETL str_endpoint_UC11R19:("aeee6ab7-7548-42f6-a1b3-731c65c43c91")
  SETL str_url:("https://dtp.cogito-project.com/api/collections/create")
  SETL str_apikey:("b44909da-473d-48f8-a0d1-96b43a796f7e")
  SETL collection_id:("")

  CURL method:("POST") url:(str_url) params:("--header \"API-Key: "+str_apikey+"\" --form \"endpointId="+str_endpoint_UC11R19+"\" --form \"projectId="+project_id+"\"") result:str_respbody
  IF (search(str_respbody,"ERROR:",0) != -1) {
    CC "AdoScript" ERRORBOX (str_respbody)
  }  ELSE {
    SETL collection:(fromJson(str_respbody))
    SETL collection_id:(collection["id"])
  }
}

PROCEDURE global DTP_SET_COMPLETE_COLLECTION collection_id:string {
  SETL str_url:("https://dtp.cogito-project.com/api/collections/"+collection_id+"/status")
  SETL str_apikey:("b44909da-473d-48f8-a0d1-96b43a796f7e")

  CURL method:("POST") url:(str_url) params:("--header \"API-Key: "+str_apikey+"\" --form \"status=COMPLETED\"") result:str_respbody
  IF (search(str_respbody,"ERROR:",0) != -1) {
    CC "AdoScript" ERRORBOX (str_respbody)
  }
}

PROCEDURE global DTP_GET_COLLECTION_FILES collection_id:string files_array:reference {
  SETL str_url:("https://dtp.cogito-project.com/api/collections/"+collection_id+"/files")
  SETL str_apikey:("b44909da-473d-48f8-a0d1-96b43a796f7e")
  SETL files_array:("")

  CURL method:("GET") url:(str_url) params:("--header \"API-Key: "+str_apikey+"\"") result:str_respbody
  IF (search(str_respbody,"ERROR:",0) != -1) {
    CC "AdoScript" ERRORBOX (str_respbody)
  } ELSIF (str_respbody = "") {
    CC "AdoScript" ERRORBOX ("Empty files response for collection " + collection_id)
  } ELSE {
    SETL resp_json:(fromJson(str_respbody))
    IF (type(resp_json) = "map") {
      IF (type(resp_json["error"]) != "undefined") {
        CC "AdoScript" ERRORBOX (resp_json["error"])
      }
    } ELSE {
      SETL files_array:(resp_json)
    }
  }
}

PROCEDURE global DTP_WAIT_COLLECTION_FILE_URL collection_id:string file_url:reference file_name:reference {
  SETL file_url:("")
  SETL file_name:("")
  SETL counter:(0)
  WHILE (1) {
    CC "AdoScript" SLEEP ms:1000
    SETL counter:(counter+1)
    #CC "AdoScript" VIEWBOX text:(collection_id)
    DTP_GET_COLLECTION_FILES collection_id:(collection_id) files_array:files_array
    #CC "AdoScript" VIEWBOX text:(files_array)
    IF (type(files_array) != "array") {
      BREAK
    }
    FOR i from:(0) to:(LEN files_array - 1) {
      IF (files_array[i, "extension"] = "JSON") {
        SETL file_url:(files_array[i, "url"])
        SETL file_name:(files_array[i, "name"])
        BREAK
      }
    }
    IF (file_url != "") {
      BREAK
    }
    IF (counter MOD 10 = 0) {
      CC "AdoScript" QUERYBOX ("The DTP is taking too much time to generate the AS PLANNED JSON in the collection " +collection_id + "\nWould you like to continue waiting?") yes-no
      IF (endbutton = "no") {
        BREAK
      }
    }
  }
}

PROCEDURE global DTP_UPLOAD_COLLECTION_FILE collection_id:string file_name:string file_content:string {
  SETL str_url:("https://dtp.cogito-project.com/api/collections/"+collection_id+"/upload")
  SETL str_apikey:("b44909da-473d-48f8-a0d1-96b43a796f7e")
  CC "AdoScript" GET_TEMP_FILENAME
  SETL sTempFolder: (copy ( filename , 0 , bsearch ( filename , "\\" , (LEN filename)-1 )+1 ))
  SETL temp_file:(sTempFolder+file_name)

  CC "AdoScript" FWRITE file:(temp_file) text:(file_content) append: 0 binary: 0 base64: 0
  CURL method:("POST") url:(str_url) params:("--header \"API-Key: "+str_apikey+"\" --form \"files=@"+temp_file+"\"") result:str_respbody
  CC "AdoScript" FILE_DELETE file:(temp_file)
}

PROCEDURE global COGITO_LOAD_JSON_AND_IMPORT_REMOTE {
  #ASK_COGITO_CREDENTIALS username:username password:password
  IF (cogito_username = "" OR cogito_password = "") {
    CC "AdoScript" ERRORBOX ("Login to COGITO first")
    EXIT
  }
  DTP_LOGIN username:(cogito_username) password:(cogito_password) access_token:access_token email:email
  IF (email = "") {
    EXIT
  }
  DTP_GET_FILTERED_PROJECTS email:(email) name_array:enabled_name_array id_array:enabled_id_array
  SELECT_COGITO_PROJECT name_array:(enabled_name_array) id_array:(enabled_id_array) project_id:project_id
  IF (project_id = "") {
    EXIT
  }
  DTP_CREATE_DOWNLOAD_COLLECTION project_id:(project_id) collection_id:collection_id
  DTP_SET_COMPLETE_COLLECTION collection_id:(collection_id)
  DTP_WAIT_COLLECTION_FILE_URL collection_id:(collection_id) file_url:file_url file_name:file_name
  IF (file_url="") {
    EXIT
  }
  CURL method:("GET") url:(file_url) params:("") result:sJSON
  CC "AdoScript" VIEWBOX title:"DEBUG: JSON retrived from DTP" text:(sJSON)

  CC "Application" GET_DATE_TIME date-format:"YYYY.MM.DD" time-format:"HH:MM:SS"
  COGITO_IMPORT_NEW sJSON:(sJSON) sModelname:(file_name + "-" + date + "_" + time) sModelGroup: ("Exercises")
  CC "AdoScript" INFOBOX "Import Completed"
}

PROCEDURE global OLIVE_UPLOAD_MODEL project_id:string json:string {
  SETL str_url:("https://innovation-laboratory.org/micro-service-controller-rest/rest/msc/callMicroserviceForced?microserviceId=269793df-7abb-434e-b3e3-6255fb14b77d&operationId=saveModel_timescale")
  CC "AdoScript" GET_TEMP_FILENAME
  SETL sTmp:(filename)
  CC "AdoScript" FWRITE file:(sTmp) text:("{\"project_id\":{\"value\":\""+project_id+"\"}, \"json\":{\"value\": "+mstr(json)+"}}") append: 0 binary: 0 base64: 0
  CURL method:("POST") url:(str_url) params:("--header \"Content-Type: application/json\" --data @"+sTmp) result:str_respbody
  #CC "AdoScript" VIEWBOX title:"DEBUG" text:(sTmp+"\n"+project_id+"\n"+str_respbody)
  CC "AdoScript" FILE_DELETE file:(sTmp)
}

#COGITO_LOAD_JSON_AND_IMPORT

PROCEDURE global COGITO_LOAD_JSON_AND_IMPORT_LOCAL {
  CC "AdoScript" FILE_DIALOG open filter1:"JSON" type1:"*.json"
  IF (endbutton = "ok") {
    CC "AdoScript" FREAD file: (path)
    CC "Application" GET_DATE_TIME date-format:"YYYY.MM.DD" time-format:"HH:MM:SS"
    COGITO_IMPORT_NEW sJSON:(text) sModelname:("DEMO" + "-" + date + "_" + time) sModelGroup: ("Exercises")
    CC "AdoScript" INFOBOX "Import Completed"
  }
}

SETG cogito_username:("")
SETG cogito_password:("")
PROCEDURE global COGITO_LOGIN {
  SETG cogito_username:("")
  SETG cogito_password:("")
  ASK_COGITO_CREDENTIALS username:username password:password
  IF (username = "" AND password = "") {
    EXIT
  }
  DTP_LOGIN username:(username) password:(password) access_token:access_token email:email
  IF (email = "") {
    EXIT
  }
  SETG cogito_username:(username)
  SETG cogito_password:(password)
  CC "AdoScript" INFOBOX ("Login Successful " + email)
}

PROCEDURE global COGITO_LOGOUT {
  SETG cogito_username:("")
  SETG cogito_password:("")
  CC "AdoScript" INFOBOX "Logout Successful"
}

PROCEDURE global COGITO_EXPORT_DIALOG_REMOTE {
  #ASK_COGITO_CREDENTIALS username:username password:password
  IF (cogito_username = "" OR cogito_password = "") {
    CC "AdoScript" ERRORBOX ("Login to COGITO first")
    EXIT
  }
  DTP_LOGIN username:(cogito_username) password:(cogito_password) access_token:access_token email:email
  IF (email = "") {
    EXIT
  }
  DTP_GET_FILTERED_PROJECTS email:(email) name_array:enabled_name_array id_array:enabled_id_array
  SELECT_COGITO_PROJECT name_array:(enabled_name_array) id_array:(enabled_id_array) project_id:project_id
  IF (project_id = "") {
    EXIT
  }
  CC "CoreUI" MODEL_SELECT_BOX oktext:"Export" boxtext:"Select refined process schedule to export to the COGITO DTP" title:"Model Export"
  IF (endbutton != "ok") {
    EXIT
  }
  COGITO_EXPORT_JSON_NEW nModelId:(VAL modelids) nExportBIM:(0) json:json_map
  SETL sJSON:(mapToJson(json_map))

  DTP_CREATE_UPLOAD_COLLECTION project_id:(project_id) collection_id:collection_id
  DTP_UPLOAD_COLLECTION_FILE collection_id:(collection_id) file_name:(project_id+".json") file_content:(sJSON)
  DTP_SET_COMPLETE_COLLECTION collection_id:(collection_id)
  CC "AdoScript" VIEWBOX text:("collection_id: " + collection_id)
  #OLIVE_UPLOAD_MODEL project_id:(json_map["project_id"]) json:(sJSON)
  COGITO_EXPORT_JSON_NEW nModelId:(VAL modelids) nExportBIM:(1) json:json_map_bim
  OLIVE_UPLOAD_MODEL project_id:(json_map_bim["project_id"]) json:(mapToJson(json_map_bim))
  CC "AdoScript" INFOBOX ("Export Completed")
}

PROCEDURE global COGITO_EXPORT_DIALOG_LOCAL {
  CC "ImportExport" SHOW_EXPORT_DLG multi-select:0 mode: "json" title: "Select the Models to export" filedescription: "json format" fileextension: "*.json"
  IF (endbutton != "ok") {
    EXIT
  }
  SETL sExportPath:(filename)
  COGITO_EXPORT_JSON_NEW nModelId:(VAL modelids) nExportBIM:(0) json:json_map
  SETL sJSON:(mapToJson(json_map))
  CC "AdoScript" FWRITE file:(sExportPath) text:(sJSON) append:0 binary:0 base64:0
  #COGITO_EXPORT_JSON_NEW nModelId:(VAL modelids) nExportBIM:(1) json:json_map_bim
  #OLIVE_UPLOAD_MODEL project_id:(json_map_bim["project_id"]) json:(mapToJson(json_map_bim))
  CC "AdoScript" INFOBOX "Export Completed"
}

PROCEDURE global COGITO_UNFOLD_PROCESS_DIALOG {
  CC "CoreUI" MODEL_SELECT_BOX oktext:"Unfold" boxtext:"Please select your process models:" title:"Unfold process"
  IF (endbutton != "ok") {
    EXIT
  }
  COGITO_EXPORT_JSON_NEW nModelId:(VAL modelids) nExportBIM:(1) json: json_map
  CC "Core" GET_MODEL_INFO modelid:(VAL modelids)
  #CC "AdoScript" VIEWBOX title:("DEBUG: UNFOLDED JSON") text:(sJSON)
  CC "Application" GET_DATE_TIME date-format:"YYYY.MM.DD" time-format:"HH:MM:SS"
  COGITO_IMPORT_MAP json_map:(json_map) sModelname:(modelname + "-UNFOLD" + "-" + date + "_" + time) sModelGroup: ("Exercises") nFilterEl:(1)
  CC "AdoScript" INFOBOX "Unfolding Completed"
}

PROCEDURE global COGITO_LOAD_HS_JSON_AND_IMPORT nTaskId: integer {
  CC "AdoScript" FILE_DIALOG open filter1:"JSON" type1:"*.json"
  IF (endbutton = "ok") {
    CC "AdoScript" FREAD file: (path)
    COGITO_IMPORT_HS_NEW sJSON:(text) nTaskId:(nTaskId)
    CC "AdoScript" INFOBOX "Import Completed"
  }
}

PROCEDURE global COGITO_OPTIMIZE_PROCESS nModelId:integer json_map:map optimizations_array:array {
  #process the following JSON from the optimization service:
#[{
#    "description": "cheapest schedule",
#    "limiting_resource_list":["5", "13"],
#    "tasks": {
#        "original_construction_task_or_pms_generated_task_id_1": {
#            "critical_activity": true/false,
#            "start_time": "",
#            "end_time": "",
#            "duration": "",
#            "late_start_time": "",
#            "late_end_time": "",
#            "early_start_time": "",
#            "early_end_time": "",
#            "total_float": "",
#            "crew_number": 1,
#        }
#    },
#    "schedule_gantt_B64": "...OPTIONAL..."
#}, {
#    "description": "shortest schedule",
#    "limiting_resource_list":["5", "13"],
#    "tasks": {
#        "original_construction_task_or_pms_generated_task_id_1": {
#            "critical_activity": true/false,
#            "start_time": "",
#            "end_time": "",
#            "duration": "",
#            "late_start_time": "",
#            "late_end_time": "",
#            "early_start_time": "",
#            "early_end_time": "",
#            "total_float": "",
#            "crew_number": 1,
#        }
#    },
#    "schedule_gantt_B64": "...OPTIONAL..."
#}, ...]

  #SETL optimizations_array:({})
  CC "AdoScript" INFOBOX ("The Optimization has identified " + (STR (LEN optimizations_array)) + " alternative schedules.\nA new process model for each alternative schedule will now be created.")
  
  CC "Core" GET_MODEL_BASENAME modelid:(nModelId)
  SETL model_name:(basename)
  SETL empty_coord_y:(0cm)
  SETL tasks_map:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (tasks_map, "dummy"))
  SETL resources_map:(json_map["resources"])
  CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(nModelId) classname:"Sub-Process (BPMN)"
  FOR sTaskId in:(objids) {
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Task Id") as-string
    SETL task_id:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Name") as-string
    SETL task_name:(val)
    SETL tasks_map[task_id]:(task_name)

    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Position")
    LEO parse:(val) get-tmm-value:x:"x" get-tmm-value:y:"y"
    IF (y > empty_coord_y) {
      SETL empty_coord_y:(y)
    }
  }

  FOR i from:(0) to:(LEN optimizations_array - 1) {
    SETL optimization_map:(optimizations_array[i])
    CC "Modeling" CLOSE modelid:(nModelId)
    CC "Core" LOAD_MODEL modelid:(nModelId)
    CC "Core" SAVE_MODEL_AS modelid:(nModelId) basename:(model_name + " - OPTIMIZATION " + STR (i+1)) version:""
    IF (ecode != 0) {
      CC "AdoScript" ERRORBOX ("Impossible to create a copy of the model " + model_name)
      EXIT
    }
    CC "Modeling" OPEN modelids:(newmodelid)

    FOR tasks_key_i from:(0) to:(LEN optimization_map["tasks"] - 1) {
      SETL task_id:(optimization_map["tasks"].key(tasks_key_i))
      IF (type(tasks_map[task_id]) = "undefined") {
        NEXT
      }
      SETL task_name:(tasks_map[task_id])
      SETL optimization_task_map:(optimization_map["tasks", task_id])

      CC "Core" GET_CLASS_ID classname:("Sub-Process (BPMN)")
      CC "Core" GET_OBJ_ID modelid:(newmodelid) classid:(classid) objname:(task_name)
      SETL nObjId:(objid)

      CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("critical_activity") val:(cond(optimization_task_map["critical_activity"]=1,"true","false")) as-string
      CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("duration") val:(optimization_task_map["duration"]) as-string
      CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("late_start_time") val:(optimization_task_map["late_start_time"]) as-string
      CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("late_end_time") val:(optimization_task_map["late_end_time"]) as-string
      CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("early_start_time") val:(optimization_task_map["early_start_time"]) as-string
      CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("early_end_time") val:(optimization_task_map["early_end_time"]) as-string
      CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("total_float") val:(optimization_task_map["total_float"]) as-string

      CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("crew_number") val:(optimization_task_map["crew_number"]) as-string
      CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("Start Date") val:(optimization_task_map["start_time"]) as-string
      CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("End Date") val:(optimization_task_map["end_time"]) as-string
    }

    SETL description_text:("Optimization Results Description:\n" + optimization_map["description"] + "\n\nBottleneck Resources:\n")
    FOR resources_i from:(0) to:(LEN optimization_map["limiting_resource_list"] - 1) {
      SETL resource_id:(optimization_map["limiting_resource_list", resources_i])
      IF (type(resources_map[resource_id]) != "undefined") {
        SETL description_text:(description_text + "- " + resources_map[resource_id, "name"] + " (" + resources_map[resource_id, "type"] + ") : " + STR resources_map[resource_id, "quantity"] + "\n")
      }
    }
    IF (LEN optimization_map["limiting_resource_list"] = 0) {
      SETL description_text:(description_text + "none")
    }

    #Add a note in the model with the schedule_gantt_B64 when available
    CC "Core" GET_CLASS_ID classname:"Note"
    CC "Core" CREATE_OBJ modelid:(newmodelid) classid:(classid) objname:("Optimization Notes")
    IF (ecode != 0) {
      CC "AdoScript" ERRORBOX (errtext)
    } ELSE {
      CC "Modeling" SET_OBJ_POS objid:(objid) x:(2cm) y:(empty_coord_y + 4cm)
      CC "Core" SET_ATTR_VAL objid:(objid) attrname:("Description") val:(description_text) as-string
    }
    
    IF (type(optimization_map["schedule_gantt_B64"]) != "undefined") {
      SETL schedule_gantt_B64:("")
      IF (type(optimization_map["schedule_gantt_B64"]) = "string") {
        SETL schedule_gantt_B64:(optimization_map["schedule_gantt_B64"])
      }
      IF (type(optimization_map["schedule_gantt_B64"]) = "map") {
        # SETL schedule_gantt_B64:(optimization_map["schedule_gantt_B64", "part1"])
        SETL schedule_gantt_map:(optimization_map["schedule_gantt_B64"])
        
        FOR j from:(0) to:(LEN schedule_gantt_map - 1) {
          SETL schedule_gantt_B64:(schedule_gantt_map[schedule_gantt_map.key(j)])

          SETL schedule_gantt_B64:(copy(schedule_gantt_B64, 2, LEN schedule_gantt_B64 - 3))
          #CC "AdoScript" VIEWBOX text:(schedule_gantt_B64) #debug
          #SETL schedule_gantt_B64:(optimization_map["schedule_gantt_B64"])
          WHILE (LEN schedule_gantt_B64 MOD 4 != 0) {
            SETL schedule_gantt_B64:(schedule_gantt_B64 + "=")
          } 
          #CC "AdoScript" VIEWBOX text:(schedule_gantt_B64) #debug
          SETL schedule_gantt:(base64decode(schedule_gantt_B64))
          CC "AdoScript" GET_TEMP_FILENAME
          SETL schedule_gantt_file:(filename + ".png")
          CC "AdoScript" FWRITE file:(schedule_gantt_file) text:(schedule_gantt) append: 0 binary: 1 base64: 0

          CC "Core" GET_CLASS_ID classname:"Note"
          CC "Core" CREATE_OBJ modelid:(newmodelid) classid:(classid) objname:("Optimization GANTT " + STR j)
          IF (ecode != 0) {
            CC "AdoScript" ERRORBOX (errtext)
          } ELSE {
            CC "Modeling" SET_OBJ_POS objid:(objid) x:(2cm) y:((empty_coord_y + ((j+1)*4cm)) + 10cm)
            CC "Core" SET_ATTR_VAL objid:(objid) attrname:("Calculate size of graphic automatically") val:("Yes") as-string
            CC "Core" SET_ATTR_VAL objid:(objid) attrname:("External graphic") val:("ITEM \"Paint\" param:"+mstr(schedule_gantt_file)+"") as-string
          }

        }
        SETL schedule_gantt_B64:("")
      }

      IF (schedule_gantt_B64 != "") {
        SETL schedule_gantt_B64:(copy(schedule_gantt_B64, 2, LEN schedule_gantt_B64 - 3))
        #CC "AdoScript" VIEWBOX text:(schedule_gantt_B64) #debug
        #SETL schedule_gantt_B64:(optimization_map["schedule_gantt_B64"])
        WHILE (LEN schedule_gantt_B64 MOD 4 != 0) {
          SETL schedule_gantt_B64:(schedule_gantt_B64 + "=")
        } 
        SETL schedule_gantt:(base64decode(schedule_gantt_B64))
        CC "AdoScript" GET_TEMP_FILENAME
        SETL schedule_gantt_file:(filename + ".png")
        CC "AdoScript" FWRITE file:(schedule_gantt_file) text:(schedule_gantt) append: 0 binary: 1 base64: 0

        CC "Core" GET_CLASS_ID classname:"Note"
        CC "Core" CREATE_OBJ modelid:(newmodelid) classid:(classid) objname:("Optimization GANTT")
        IF (ecode != 0) {
          CC "AdoScript" ERRORBOX (errtext)
        } ELSE {
          CC "Modeling" SET_OBJ_POS objid:(objid) x:(2cm) y:(empty_coord_y + 10cm)
          CC "Core" SET_ATTR_VAL objid:(objid) attrname:("Calculate size of graphic automatically") val:("Yes") as-string
          CC "Core" SET_ATTR_VAL objid:(objid) attrname:("External graphic") val:("ITEM \"Paint\" param:"+mstr(schedule_gantt_file)+"") as-string
        }
      }
    }
    IF (type(optimization_map["schedule_lob_B64"]) != "undefined") {
      SETL schedule_lob_B64:("")
      IF (type(optimization_map["schedule_lob_B64"]) = "string") {
        SETL schedule_lob_B64:(optimization_map["schedule_lob_B64"])
      }
      IF (type(optimization_map["schedule_lob_B64"]) = "map") {
        SETL schedule_lob_B64:(optimization_map["schedule_lob_B64", "part1"])
      }

      IF (schedule_lob_B64 != "") {
        SETL schedule_lob_B64:(copy(schedule_lob_B64, 2, LEN schedule_lob_B64 - 3))
        WHILE (LEN schedule_lob_B64 MOD 4 != 0) {
          SETL schedule_lob_B64:(schedule_lob_B64 + "=")
        } 
        SETL schedule_lob:(base64decode(schedule_lob_B64))
        CC "AdoScript" GET_TEMP_FILENAME
        SETL schedule_lob_file:(filename + ".png")
        CC "AdoScript" FWRITE file:(schedule_lob_file) text:(schedule_lob) append: 0 binary: 1 base64: 0

        CC "Core" GET_CLASS_ID classname:"Note"
        CC "Core" CREATE_OBJ modelid:(newmodelid) classid:(classid) objname:("Optimization JOB")
        IF (ecode != 0) {
          CC "AdoScript" ERRORBOX (errtext)
        } ELSE {
          CC "Modeling" SET_OBJ_POS objid:(objid) x:(8cm) y:(empty_coord_y + 10cm)
          CC "Core" SET_ATTR_VAL objid:(objid) attrname:("Calculate size of graphic automatically") val:("Yes") as-string
          CC "Core" SET_ATTR_VAL objid:(objid) attrname:("External graphic") val:("ITEM \"Paint\" param:"+mstr(schedule_lob_file)+"") as-string
        }
      }
    }
    CC "Modeling" SAVE modelid:(newmodelid)
  }
}

PROCEDURE global COGITO_OPTIMIZE_DIALOG {
  CC "CoreUI" MODEL_SELECT_BOX oktext:"Optimize" boxtext:"Please select your process models:" title:"Optimize process"
  IF (endbutton != "ok") {
    EXIT
  }
  COGITO_EXPORT_JSON_NEW nModelId:(VAL modelids) nExportBIM:(0) json:json_map

  SETL sJSON:(mapToJson(json_map))
  CC "AdoScript" FILE_DIALOG saveas filter1:"JSON" type1:"*.json" filename:"schedule_export.json"
  IF (endbutton != "ok") {
    EXIT
  }
  CC "AdoScript" FWRITE file:(path) text:(sJSON) append: 0 binary: 0 base64: 0

  CC "AdoScript" FILE_DIALOG open filter1:"JSON" type1:"*.json"
  IF (endbutton != "ok") {
    EXIT
  }
  CC "AdoScript" FREAD file: (path)
  SETL optimizations_array:(fromJson(text))

  COGITO_OPTIMIZE_PROCESS nModelId:(VAL modelids) json_map:(json_map) optimizations_array:(optimizations_array)
  CC "AdoScript" INFOBOX "Optimization Completed"
}




SETG opzimization_url:("http://127.0.0.1:8000/optimizer")
PROCEDURE global UEDIN_OPTIMIZATION_SERVICE_URL_SET {
CC "AdoScript" EDITFIELD title:("Optimization service configuration") caption:("Service URL") text:(opzimization_url)
  IF (ecode != 0) {
    EXIT
  }
  SETG opzimization_url:(text)
}

PROCEDURE global UEDIN_OPTIMIZATION_SERVICE_START {
  CC "CoreUI" MODEL_SELECT_BOX oktext:"Optimize" boxtext:"Select refined process schedule to optimize" title:"Schedule Optimization"
  IF (endbutton != "ok") {
    EXIT
  }
  COGITO_EXPORT_JSON_NEW nModelId:(VAL modelids) nExportBIM:(0) json:json_map
  SETL sJSON:(mapToJson(json_map))
  CC "AdoScript" GET_TEMP_FILENAME
  SETL sTempFolder:(copy(filename, 0, bsearch(filename, "\\", (LEN filename)-1)+1))
  CC "AdoScript" FWRITE file:(filename) text:(sJSON) append: 0 binary: 0 base64: 0
  CURL method:("POST") url:(opzimization_url) params:("-H \"Content-Type: application/json\" --data \"@"+filename+"\"") result:str_respbody
  #SETL resp_json:(fromJson(str_respbody))
  SETL resp_json:({"id":"211028c0-c5be-47be-8105-22d8c3f3c0bd"})
  IF (type(resp_json["error"]) != "undefined") {
    CC "AdoScript" ERRORBOX ("Error starting the optimization: " + resp_json["error"])
    EXIT
  }
  CC "AdoScript" FILE_DELETE file:(filename)
  SETL run_id:(resp_json["id"])
  CC "Application" GET_DATE_TIME date-format:"YYYY-MM-DD" time-format:"HH.MM.SS"
  SETL temp_file:(sTempFolder + "uedin_optimization\\" + modelids + "\\" + date + "_" + time)
  CC "AdoScript" DIR_CREATE path:(sTempFolder + "uedin_optimization\\")
  CC "AdoScript" DIR_CREATE path:(sTempFolder + "uedin_optimization\\" + modelids + "\\")
  CC "AdoScript" FWRITE file:(temp_file) text:(run_id) append:0 binary:0 base64:0
  CC "AdoScript" INFOBOX ("Optimization Job Correctly started with id " + run_id)
}

PROCEDURE global UEDIN_OPTIMIZATION_SERVICE_GET_RESULTS {
  CC "CoreUI" MODEL_SELECT_BOX oktext:"Check" boxtext:"Select refined process schedule to Optimize" title:"Get Optimization Results"
  IF (endbutton != "ok") {
    EXIT
  }
  CC "AdoScript" GET_TEMP_FILENAME
  SETL sTempFolder:(copy(filename, 0, bsearch(filename, "\\", (LEN filename)-1)+1))
  SETL temp_file:(sTempFolder + "uedin_optimization\\" + modelids + "\\")
  CC "AdoScript" DIR_LIST path:(temp_file)
  CC "AdoScript" LISTBOX entries:(files) toksep:("*") title:("Started optimizations") boxtext:("Choose the optimization to check")
  IF (endbutton != "ok") {
    EXIT
  }
  SETL temp_file:(sTempFolder + "uedin_optimization\\" + modelids + "\\" + selection)
  CC "AdoScript" FREAD file:(temp_file)
  SETL run_id:(text)

  CURL method:("GET") url:(opzimization_url + "?id=" + run_id) params:("-H \"Content-Type: application/json\"") result:str_respbody

  #CC "AdoScript" VIEWBOX text:(str_respbody) #debug

  SETL optimizations_array:(fromJson(str_respbody))
  IF (type(optimizations_array) = "map") {
    CC "AdoScript" ERRORBOX ("Error from the optimization: " + optimizations_array["error"])
    #CC "AdoScript" FILE_DELETE file:(temp_file)
    EXIT
  }
  COGITO_EXPORT_JSON_NEW nModelId:(VAL modelids) nExportBIM:(0) json:json_map
  COGITO_OPTIMIZE_PROCESS nModelId:(VAL modelids) json_map:(json_map) optimizations_array:(optimizations_array)

  #CC "AdoScript" FILE_DELETE file:(temp_file)
  CC "AdoScript" INFOBOX "Optimization Completed"
}


PROCEDURE global GENERATE_TEMPLATES_FROM_SECTIONS {
  CC "CoreUI" MODEL_SELECT_BOX oktext:"Start" boxtext:"Select the process schedule for the Temmplate generation" title:"Generate Sections Templates" modeltype:("Business Process Diagram (BPMN 2.0)")
  IF (endbutton != "ok") {
    EXIT
  }
  COGITO_EXPORT_JSON_NEW nModelId:(VAL modelids) nExportBIM:(1) json:json_map

  CC "Core" GET_MODELGROUPS_OF_MODELVERSION modelid:(VAL modelids)
  CC "Core" CREATE_MODELGROUP supermgroupid:(VAL mgroupids) mgroupname:("TEMPLATES SECTIONS " + modelids)
  SETL modelgroupID:(mgroupid)

  SETL elements:(json_map["elements"])
  SETL zones:(json_map["zones"])
  SETL tasks:(json_map["tasks"])


  FOR i from:(0) to:(LEN tasks - 1) {
    SETL task_zones_list:({})
    SETL task_zones_element_map:({"dummy":"dummy_is_a_map_not_an_array"})
    SETL dummy: (merase (task_zones_element_map, "dummy"))
    SETL tasks_id:(tasks.key(i))
    SETL task:(tasks[tasks_id])
    SETL task_element_list:(cond(type(task["elements_list"]) != "undefined", task["elements_list"], task["element_list"]))
    IF (type(task_element_list) != "undefined") {
      FOR task_element_list_i from:(0) to:(LEN task_element_list - 1) {
        SETL task_element:(task_element_list[task_element_list_i])
        SETL task_element_id:("")
        SETL task_element_action:("")
        IF (type(task_element) = "string") {
          SETL task_element_id:(task_element)
        } ELSE {
          SETL task_element_id:(task_element["element_id"])
          SETL task_element_action:(task_element["action"])
        }
        IF (elements[task_element_id, "type"] != "BUILDING_ELEMENT") {
          NEXT
        }
        SETL task_zone_id:(elements[task_element_id, "zone"])
        IF (NOT (task_zone_id IN task_zones_list)) {
          SETL dummy:(aappend(task_zones_list, task_zone_id))
          SETL task_zones_element_map[task_zone_id]:(array(0))
        }
        SETL task_element_obj:({"task_element_id":task_element_id, "task_element_action":task_element_action})
        SETL task_zones_element_list:(task_zones_element_map[task_zone_id])
        SETL dummy:(aappend(task_zones_element_list, task_element_obj))
        SETL task_zones_element_map[task_zone_id]:(task_zones_element_list)
      }
    }
    IF (LEN task_zones_list = 0) {
      NEXT
    }
    SETL dummy: (task_zones_list.sort(lambda(x, y, x < y)))

    #CC "AdoScript" VIEWBOX text:(task_zones_element_map)

    CC "Core" CREATE_MODEL  modeltype:("Business Process Diagram (BPMN 2.0)") modelname:(tasks_id + " zones template") version:("1.0") mgroups:(STR modelgroupID)
    IF (ecode != 0) {
      CC "AdoScript" ERRORBOX (errtext)
      EXIT
    }
    SETL nModelIdBPMN:(modelid)
    CC "Core" LOAD_MODEL modelid:(nModelIdBPMN)
    CC "Modeling" OPEN modelids:(nModelIdBPMN)

    FOR task_zones_list_i from:(0) to:(LEN task_zones_list - 1) {
      SETL task_zone_id:(task_zones_list[task_zones_list_i])
      SETL task_zone_name:(zones[task_zone_id, "name"])


      CC "Core" GET_CLASS_ID classname:"Sub-Process (BPMN)"
      CC "Core" CREATE_OBJ modelid:(nModelIdBPMN) classid:(classid) objname:(task_zone_name)
      IF (ecode != 0) {
        CC "AdoScript" ERRORBOX (errtext)
        EXIT
      }
      SETL nObjId:(objid)
      CC "Modeling" SET_OBJ_POS objid:(nObjId) x:(2cm + (task_zones_list_i)*4cm) y:(CEIL((0+1) / 5)*4cm - 2cm)
      CC "Core" SET_ATTR_VAL objid:(nObjId) attrname:("Task Id") val:("sect"+STR(task_zones_list_i+1)) as-string

      SETL task_zones_elements_list:(task_zones_element_map[task_zone_id])
      FOR task_zones_elements_list_i from:(0) to:(LEN task_zones_elements_list - 1) {
        SETL task_element:(task_zones_elements_list[task_zones_elements_list_i])
        SETL task_element_id:(task_element["task_element_id"])
        SETL element_name:(elements[task_element_id, "name"])
        SETL element_type:(elements[task_element_id, "type"])
        SETL task_element_action:(task_element["task_element_action"])

        CC "Core" GET_CLASS_ID objid:(nObjId)
        CC "Core" GET_ATTR_ID classid:(classid) attrname:"Elements"
        CC "Core" ADD_REC_ROW objid:(nObjId) attrid:(attrid)
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("ID") val:(task_element_id) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Element_Name") val:(element_name) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Element_Type") val:(element_type) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Action") val:(task_element_action) as-string
        CC "Core" SET_ATTR_VAL objid:(rowid) attrname:("Zone") val:(task_zone_id) as-string
      }

    }
    CC "Modeling" SAVE modelid:(nModelIdBPMN)
  }

  CC "AdoScript" INFOBOX "Process Completed"
}


PROCEDURE global COGITO_EXPORT_CSV {
  #CC "CoreUI" MODEL_SELECT_BOX oktext:"Run" boxtext:"Please select your process models:" title:"Process Execution"
  CC "ImportExport" SHOW_EXPORT_DLG multi-select:0 mode: "csv" title: "Select the Schedule to Export as CSV" filedescription: "csv format" fileextension: "*.csv"
  IF (endbutton != "ok") {
    EXIT
  }
  SETL sExportPath:(filename)
  SETL nModelId:(VAL modelids)

  SETL tasks_map:({"dummy":"dummy_is_a_map_not_an_array"})
  SETL dummy: (merase (tasks_map, "dummy"))
  SETL executed_tasks_list:(array(0))

  #CC "Modeling" OPEN modelids:(nModelId)
  CC "Core" LOAD_MODEL modelid:(nModelId)

  CC "Core" GET_ALL_OBJS_OF_CLASSNAME modelid:(nModelId) classname:"Sub-Process (BPMN)"
  SETL sTaskIdList:(objids)
  FOR sTaskId in:(objids) {
    SETL task_map:({"dummy":"dummy_is_a_map_not_an_array"})
    SETL dummy: (merase (task_map, "dummy"))
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Task Id") as-string
    SETL task_id:(val)
    SETL task_map["id"]:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Name") as-string
    SETL sTaskName:(val)
    SETL task_map["name"]:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Start Date") as-string
    SETL task_map["start_time"]:(val)
    CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("End Date") as-string
    SETL task_map["end_time"]:(val)

    SETL previous_task_list:(array(0))
    CC "AQL" EVAL_AQL_EXPRESSION expr:("({\""+sTaskName+"\":\"Task (BPMN)\"} <- \"Subsequent\") OR ({\""+sTaskName+"\":\"Sub-Process (BPMN)\"} <- \"Subsequent\")") modelid: (nModelId)
    FOR sPreviousTaskId in:(objids) {
      CC "Core" GET_ATTR_VAL objid:(VAL sPreviousTaskId) attrname:("Task Id") as-string
      IF (ecode = 0) {
        SETL dummy:(aappend(previous_task_list, val))
      }
    }
    SETL task_map["previous_task_list"]:(previous_task_list)
    SETL tasks_map[task_id]:(task_map)
  }
  SETL index:(1)
  WHILE (1) {
    SETL current_tasks_list:(array(0))
    FOR sTaskId in:(sTaskIdList) {
      CC "Core" GET_ATTR_VAL objid:(VAL sTaskId) attrname:("Task Id") as-string
      SETL task_id:(val)
      IF (task_id IN executed_tasks_list) {
        NEXT
      }
      SETL task_enabled:(1)
      FOR i from:0 to:(LEN tasks_map[task_id, "previous_task_list"] - 1) {
        IF (NOT (tasks_map[task_id, "previous_task_list", i] IN executed_tasks_list)) {
          SETL task_enabled:(0)
          BREAK
        }
      }
      IF (task_enabled = 0) {
        NEXT
      }
      SETL dummy:(aappend(current_tasks_list, task_id))
    }
    IF ((LEN current_tasks_list) = 0) {
      BREAK
    }

    FOR i from:0 to:(LEN current_tasks_list - 1) {
      SETL id:(current_tasks_list[i])
      SETL tasks_map[id, "index"]:(STR(index))
      SETL dummy:(aappend(executed_tasks_list, current_tasks_list[i]))
      SETL index:(index+1)
    }
  }

  SETL csv_content:("id,name,duration,start,finish,predecessors")
  FOR i from:0 to:(LEN executed_tasks_list - 1) {
    SETL task_id:(executed_tasks_list[i])
    SETL id:(tasks_map[task_id, "index"])
    SETL name:(tasks_map[task_id, "name"])
    SETL start_time_iso:(tasks_map[task_id, "start_time"])
    SETL start_time_map:(isoDateTimeToMap(start_time_iso))
    SETL start_time:(STR(start_time_map["dayOfMonth"])+"/"+STR(start_time_map["monthOfYear"])+"/"+STR(start_time_map["years"])+" "+STR(start_time_map["hours"])+":"+STR(start_time_map["minutes"]))
    SETL end_time_iso:(tasks_map[task_id, "end_time"])
    SETL end_time_map:(isoDateTimeToMap(end_time_iso))
    SETL end_time:(STR(end_time_map["dayOfMonth"])+"/"+STR(end_time_map["monthOfYear"])+"/"+STR(end_time_map["years"])+" "+STR(end_time_map["hours"])+":"+STR(end_time_map["minutes"]))
    SETL duration:(STR(isoDateToDays(end_time_iso) - isoDateToDays(start_time_iso) + 1))
    SETL predecessors:("")
    FOR j from:0 to:(LEN tasks_map[task_id, "previous_task_list"] - 1) {
      SETL previd:(tasks_map[task_id, "previous_task_list", j])
      SETL predecessors:(predecessors + "," + tasks_map[previd, "index"])
    }
    IF (LEN predecessors != 0) {
      SETL predecessors:(copy(predecessors, 1, LEN predecessors))
    }
    SETL csv_content:(csv_content + "\n" + mstr(id) + "," + mstr(name) + "," +  mstr(duration) + "," + mstr(start_time) + "," + mstr(end_time) + "," + mstr(predecessors))
  }

  #SETL csv_content:(csv_content + "\n" + mstr(tasks_map[started_task_id, "id"]) + "," + mstr(tasks_map[started_task_id, "name"]) + "," + mstr(text))

  CC "AdoScript" FWRITE file: (sExportPath) text: (csv_content) append: 0 binary: 0 base64: 0
  CC "AdoScript" INFOBOX "Export Completed"
}



#ITEM "Import H&S"
#COGITO_LOAD_HS_JSON_AND_IMPORT nTaskId:(objid)



#CC "CoreUI" MODEL_SELECT_BOX oktext:"Order" boxtext:"Please select your process models:" title:"Process Order"
#ORDER_MODEL modelid:(VAL modelids)

#maps
#SETL test:({"a":"valueA", "b":{1,2,3}})
#SETL test["c"]:(array(0))
#CC "AdoScript" VIEWBOX  text:(test)
#SETL test:({"dummy":"dummy"})
#SETL test["a"]:({"a":array(0)})
#CC "AdoScript" VIEWBOX  text:(test)

#SETL test:({"a":"valueA", "b":{1,2,3}})
#CC "AdoScript" VIEWBOX  text:(STR LEN test)
#CC "AdoScript" VIEWBOX  text:(test.key(0))

#CC "AdoScript" VIEWBOX text:(fromJson("{\"a\":\"valA\", \"subMap\":{\"a\":0}, \"anArray\":[1, {}, 3]}"))

#SETL test:({"a":"valueA", "b":{1,2,3}, "c":{"c1":"val"}, "d":12, "e":12.3})
#SETL dummy: (merase (test, "e"))
#CC "AdoScript" VIEWBOX  text:(type(test["f"]))

#arrays
#SETL arr:({"a", "b"})
#SETL temp:(aappend(arr, "c"))
#SETL temp:(aappend(arr, {"sub1","sub2"}))
#SETL temp:(aappend(arr, {"map1":"m1"}))
#SETL temp:(aappend(arr, "f"))
#SETL temp:(aerase(arr, 5))
#CC "AdoScript" VIEWBOX  text:(arr)
#CC "AdoScript" VIEWBOX  text:(arr[2])
#CC "AdoScript" VIEWBOX  text:(arr[3, 0])
#CC "AdoScript" VIEWBOX  text:(arr[4, "map1"])

#CC "AdoScript" VIEWBOX text:(applyAdoxxTimeToIsoDateTimeString("2023-04-05T14:00:00.000.", "00:005:00:00:00"))

#CC "AdoScript" VIEWBOX text:(compareIsoDateTimeStrings("2023-04-05T14:00:00", applyAdoxxTimeToIsoDateTimeString("2023-04-05T14:00:00", "00:005:00:00:00")))
